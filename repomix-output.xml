This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.development
.env.production
.gitignore
.stylelintrc.json
.yarnrc
.yarnrc.yml
api/swagger.json
build-api.js
eslint.config.js
index.html
MARS.client.esproj
package.json
public/vite.svg
README.md
run.bat
src/app/App.module.scss
src/app/App.tsx
src/app/global.scss
src/app/index.ts
src/app/main.tsx
src/assets/react.svg
src/components/ChatHorizontal/ChatHorizontal.tsx
src/components/ChatHorizontal/Message.module.css
src/components/ChatHorizontal/Message.tsx
src/components/ChatVertical/badge.css
src/components/ChatVertical/bMessage.module.scss
src/components/ChatVertical/ChatVertical.module.scss
src/components/ChatVertical/ChatVertical.tsx
src/components/ChatVertical/ContentPart.tsx
src/components/ChatVertical/Message.module.scss
src/components/ChatVertical/Message.tsx
src/components/Checkers/Checkers.tsx
src/components/FumoFriday/Cirno.tsx
src/components/FumoFriday/FumoFriday.tsx
src/components/FumoFriday/FumoFridayController.tsx
src/components/FumoFriday/index.ts
src/components/FumoFriday/Reimu.tsx
src/components/FumoFriday/Styles.module.scss
src/components/HighliteMessage/HighliteMessage.tsx
src/components/HighliteMessage/Message.module.scss
src/components/HighliteMessage/Message.tsx
src/components/MainPage/MainPage.tsx
src/components/PyroAlerts/Alert.tsx
src/components/PyroAlerts/HighPriorityAlert.tsx
src/components/PyroAlerts/Primitive/Audio.tsx
src/components/PyroAlerts/Primitive/Image.tsx
src/components/PyroAlerts/Primitive/index.ts
src/components/PyroAlerts/Primitive/Media.module.scss
src/components/PyroAlerts/Primitive/TelegramSticker.tsx
src/components/PyroAlerts/Primitive/Video.tsx
src/components/PyroAlerts/Primitive/Voice.tsx
src/components/PyroAlerts/PyroAlerts.tsx
src/components/RandomMem/RandomMem.tsx
src/components/ScreenParticles/Confetty.tsx
src/components/ScreenParticles/EmojiParticles.tsx
src/components/ScreenParticles/Firework.tsx
src/components/ScreenParticles/index.ts
src/components/ScreenParticles/Manager.tsx
src/components/shaders/FireShader/shader.glsl
src/components/SoundRequest/ChoosePath.module.scss
src/components/SoundRequest/ChoosePath.tsx
src/components/SoundRequest/CurrentTrack/Animations/AnimatedGradientBackground.tsx
src/components/SoundRequest/CurrentTrack/Animations/AnimationControl.tsx
src/components/SoundRequest/CurrentTrack/CurrentTrack.module.scss
src/components/SoundRequest/CurrentTrack/CurrentTrack.tsx
src/components/SoundRequest/CurrentTrack/CurrentTrackManager.tsx
src/components/SoundRequest/CurrentTrack/index.ts
src/components/SoundRequest/CurrentTrack/SignalRHubWrapper.tsx
src/components/SoundRequest/index.ts
src/components/SoundRequest/TrackList/TrackList.tsx
src/components/SoundRequest/VideoScreen/VideoScreen.tsx
src/components/WaifuAlerts/helper.ts
src/components/WaifuAlerts/WaifuAlerts.module.scss
src/components/WaifuAlerts/WaifuAlerts.tsx
src/components/WaifuAlerts/WaifuRoulette.tsx
src/routes/ErrorPage.module.scss
src/routes/ErrorPage.tsx
src/routes/LinkTree/LinkTreeMenu.css
src/routes/LinkTree/LinkTreeMenu.tsx
src/routes/Routes.tsx
src/shared/api/generated/baza.ts
src/shared/components/KeyWordText/index.ts
src/shared/components/KeyWordText/KeyWordedText.tsx
src/shared/components/PageName/PageName.tsx
src/shared/components/RainbowText/hsl2rgb.ts
src/shared/components/RainbowText/rainbowGradient.ts
src/shared/components/RainbowText/RainbowText.tsx
src/shared/MIME_types.ts
src/shared/styles/animate.module.scss
src/shared/twitchStore/twitchStore.ts
src/shared/Utils/Announce/Announce.module.scss
src/shared/Utils/Announce/Announce.tsx
src/shared/Utils/BigTexts/aa.module.scss
src/shared/Utils/BigTexts/BigTextBlockForAudio.tsx
src/shared/Utils/BigTexts/BigTextBlockForVoice.tsx
src/shared/Utils/BigTexts/BigTextStyles.module.scss
src/shared/Utils/FullText/FullText.tsx
src/shared/Utils/index.ts
src/vite-env.d.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.development">
VITE_BASE_PATH=http://localhost:9255/
</file>

<file path=".env.production">
VITE_BASE_PATH=http://localhost:9155/
</file>

<file path=".stylelintrc.json">
{
  "extends": [
    "stylelint-config-standard",
    "stylelint-prettier/recommended",
    "stylelint-config-standard-scss"
  ],
  "rules": {
    "scss/at-rule-no-unknown": true,
    "no-invalid-position-at-import-rule": null,
    "selector-class-pattern": null,
    "selector-pseudo-class-no-unknown": [
      true,
      {
        "ignorePseudoClasses": ["global"]
      }
    ]
  },
  "defaultSeverity": "error"
}
</file>

<file path=".yarnrc">
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


yarn-path ".yarn/releases/yarn-1.22.22.cjs"
</file>

<file path=".yarnrc.yml">
nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-4.6.0.cjs
</file>

<file path="build-api.js">
import { resolve } from "path";
import { generateApi } from "swagger-typescript-api";
import process from "process";

const params = {
  input: resolve(process.cwd(), "./api/swagger.json"),
  output: resolve(process.cwd(), "./src/shared/api/generated/"),
  name: "baza.ts",
  cleanOutput: true,
  prettier: {
    trailingComma: "all",
    tabWidth: 4,
    printWidth: 160,
  },
  generateClient: false,
  sortTypes: true,
  extractEnums: true,
  codeGenConstructs: (constructs) => ({
    ...constructs,
    NullValue: () => "undefined", // Заменяем null на undefined
    TypeField: ({ readonly, key, value }) => {
      // Обрабатываем nullable типы в полях
      const finalValue = value.includes(" | null")
        ? value.replace(" | null", " | undefined") // Заменяем null на undefined
        : value;
      return [...(readonly ? ["readonly "] : []), key, ": ", finalValue].join(
        "",
      );
    },
  }),
};

generateApi(params);
</file>

<file path="MARS.client.esproj">
<Project Sdk="Microsoft.VisualStudio.JavaScript.Sdk/1.0.1738743">
  <PropertyGroup>
    <StartupCommand>npm run dev</StartupCommand>
    <JavaScriptTestRoot>src\</JavaScriptTestRoot>
    <JavaScriptTestFramework>Jest</JavaScriptTestFramework>
    <!-- Allows the build (or compile) script located on package.json to run on Build -->
    <ShouldRunBuildScript>false</ShouldRunBuildScript>
    <!-- Folder where production build objects will be placed -->
    <BuildOutputFolder>$(MSBuildProjectDirectory)\dist</BuildOutputFolder>
    <BuildCommand>npm run build</BuildCommand>
    <CleanCommand>npm run lint:all</CleanCommand>
  </PropertyGroup>
</Project>
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```
</file>

<file path="src/app/App.module.scss">
body {
  text-shadow:
    rgb(0, 0, 0) 2px 0px 0px,
    rgb(0, 0, 0) 1.75517px 0.958851px 0px,
    rgb(0, 0, 0) 1.0806px 1.68294px 0px,
    rgb(0, 0, 0) 0.141474px 1.99499px 0px,
    rgb(0, 0, 0) -0.832294px 1.81859px 0px,
    rgb(0, 0, 0) -1.60229px 1.19694px 0px,
    rgb(0, 0, 0) -1.97998px 0.28224px 0px,
    rgb(0, 0, 0) -1.87291px -0.701566px 0px,
    rgb(0, 0, 0) -1.30729px -1.5136px 0px,
    rgb(0, 0, 0) -0.421592px -1.95506px 0px,
    rgb(0, 0, 0) 0.567324px -1.91785px 0px,
    rgb(0, 0, 0) 1.41734px -1.41108px 0px,
    rgb(0, 0, 0) 1.92034px -0.558831px 0px;
}
</file>

<file path="src/app/App.tsx">
import "./App.module.scss";
import "./global.scss";

import Routes from "../routes/Routes";
import useTwitchStore from "../shared/twitchStore/twitchStore";
import { SignalRContext } from ".";

function App() {
  const init = useTwitchStore((state) => state.init);

  SignalRContext.useSignalREffect(
    "posttwitchinfo",
    (clientId: string, clientSecret: string) => {
      init(clientId, clientSecret);
    },
    [],
  );

  return (
    <>
      <Routes />
    </>
  );
}

export default App;
</file>

<file path="src/app/global.scss">
.emote {
  height: 100%;
  margin: 5px 5px;
}
</file>

<file path="src/app/index.ts">
import * as signalR from "react-signalr";

export const SignalRContext = signalR.createSignalRContext({});
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/ChatVertical/badge.css">

</file>

<file path="src/components/ChatVertical/bMessage.module.scss">
// Message.module.scss
.container {
  height: auto;
  max-height: 8vh;
  min-height: 3vh;
  margin-top: 1vh;
}

.head {
  height: 50%;
}

.badgesAndNickname {
  height: 100%;
  width: 100%;
}

.badges {
  display: inline-block;
  height: auto;

  > img {
    height: auto;

    width: auto;
  }
}

.nickname {
  display: inline-block;
}

.messageWrapper {
  height: auto;
}

.message {
  height: auto;

  > img {
    height: auto;
  }

  > div {
    height: auto;

    > img {
      height: auto;
    }
  }
}
</file>

<file path="src/components/Checkers/Checkers.tsx">
export default function Checkers() {
  return <div></div>;
}
</file>

<file path="src/components/FumoFriday/FumoFriday.tsx">
import { useState } from "react";

import Announce from "../../shared/Utils/Announce/Announce";
import { FumoFridayController } from "./FumoFridayController";

export function FumoFriday() {
  const [announced, setAnnounced] = useState<boolean>(false);
  document.title = "FumoFriday";

  return (
    <>
      {!announced && (
        <Announce callback={() => setAnnounced(true)} title={"FumoFriday"} />
      )}
      <FumoFridayController />
    </>
  );
}
</file>

<file path="src/components/FumoFriday/index.ts">
export { FumoFriday } from "./FumoFriday";
</file>

<file path="src/components/HighliteMessage/HighliteMessage.tsx">
import { useState } from "react";

import Announce from "../../shared/Utils/Announce/Announce";
import Message from "./Message";

export default function HighliteMessage() {
  const [announced, setAnnounced] = useState(false);

  return (
    <>
      {!announced && (
        <Announce
          title={"HighliteMessage"}
          callback={() => setAnnounced(true)}
        />
      )}
      {<Message />}
    </>
  );
}
</file>

<file path="src/components/MainPage/MainPage.tsx">
function MainPage() {
  return <></>;
}

export default MainPage;
</file>

<file path="src/components/PyroAlerts/Primitive/index.ts">
export { Image } from "./Image";
export { Video } from "./Video";
export { Audio } from "./Audio";
export { Voice } from "./Voice";
</file>

<file path="src/components/ScreenParticles/index.ts">
export function randomInRange(min: number, max: number) {
  return Math.random() * (max - min) + min;
}
</file>

<file path="src/components/shaders/FireShader/shader.glsl">
#define G vec3(iResolution.xy,iTime)
void mainImage(out vec4 l,vec2 o){l-=l;
  for(float b=-1.;b<1.;b+=21e-3){
    vec2 e=cos(b*64.+G.z+vec2(0,11))*sqrt(1.-b*b);
    l+=(cos(b+vec4(9,2,3,2))+1.)*(1.-e.y)/
    dot(e=(o+o-G.xy)/G.y+vec2(e.x,b)/(e.y+2.),e)/3e3;}}
</file>

<file path="src/components/SoundRequest/ChoosePath.module.scss">
/* ChoosePath.css */
.choose-path {
  display: flex;
  height: 100vh;
}

.left-path, .right-path {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  text-decoration: none;
  font-size: 24px;
}

.left-path {
  background-color: green;
}

.right-path {
  background-color: red;
}
</file>

<file path="src/components/SoundRequest/ChoosePath.tsx">
import styles from "./ChoosePath.module.scss";

export const ChoosePath: React.FC = () => {
  return (
    <div className="choose-path">
      <a href="/sr/tracklist" className={styles["left-path"]}>
        TrackList
      </a>
      <a href="/sr/videoscreen" className={styles["right-path"]}>
        VideoScreen
      </a>
    </div>
  );
};
</file>

<file path="src/components/SoundRequest/CurrentTrack/Animations/AnimatedGradientBackground.tsx">
// AnimatedGradientBackground.tsx
import { useEffect } from "react";
import { motion } from "framer-motion";

interface AnimatedGradientBackgroundProps {
  children: React.ReactNode;
  colors?: string[];
  duration?: number;
  gradientAngle?: number;
}

export default function AnimatedGradientBackground({
  children,
  colors = ["#ee7752", "#e73c7e", "#23a6d5", "#23d5ab"],
  duration = 15,
  gradientAngle = -45,
}: AnimatedGradientBackgroundProps) {
  // Добавляем глобальные стили для анимации градиента
  useEffect(() => {
    const style = document.createElement("style");
    style.textContent = `
      @keyframes gradient {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }
    `;
    document.head.append(style);

    return () => style.remove();
  }, []);

  const backgroundStyle = {
    background: `linear-gradient(${gradientAngle}deg, ${colors.join(", ")})`,
    backgroundSize: "400% 400%",
    animation: `gradient ${duration}s ease infinite`,
  };

  return (
    <motion.div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        overflow: "hidden",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxShadow: "0 0 10px rgba(0, 0, 0, 0.5)",
        borderRadius: "5rem",
        textShadow: "2px 2px 4px rgba(0, 0, 0, 0.5)",
        zIndex: 1000,
        ...backgroundStyle,
      }}
    >
      {children}
    </motion.div>
  );
}
</file>

<file path="src/components/SoundRequest/CurrentTrack/index.ts">
import * as signalR from "react-signalr";

export const SignalRContext = signalR.createSignalRContext({});
</file>

<file path="src/components/SoundRequest/index.ts">
import { ChoosePath } from "./ChoosePath";
import { TrackList } from "./TrackList/TrackList";
import { VideoScreen } from "./VideoScreen/VideoScreen";

export default { ChoosePath, TrackList, VideoScreen };
</file>

<file path="src/components/SoundRequest/TrackList/TrackList.tsx">
export function TrackList() {
  return (
    <div>
      {/** TRACKLIST */}
      <div>
        <div></div>
        <div></div>
      </div>
      {/** PLAYER */}
      <div></div>
    </div>
  );
}
</file>

<file path="src/components/SoundRequest/VideoScreen/VideoScreen.tsx">
export function VideoScreen() {
  return <div>VideoScreen</div>;
}
</file>

<file path="src/components/WaifuAlerts/WaifuRoulette.tsx">
import "react-roulette-pro/dist/index.css";

import { CSSProperties, useRef, useState } from "react";
import RoulettePro, { PrizeType } from "react-roulette-pro";

import animate from "../../shared/styles/animate.module.scss";
import { getRandomColor } from "../../shared/Utils";
import styles from "./WaifuAlerts.module.scss";

interface Props {
  rouletteIndex: number;
  prizes: PrizeType[];
  callback: () => void;
  name: string;
  color?: string;
}

export default function WaifuRoulette({
  rouletteIndex,
  prizes,
  callback,
  name,
  color,
}: Props) {
  if (prizes.length === 0) {
    throw new Error("Prizes is empty");
  }

  const [rouletteStart, setRouletteStart] = useState(false);
  const rouletteDiv = useRef<HTMLDivElement>(null);
  const heightDiv = useRef<HTMLDivElement>(null);
  const [visible, setVisible] = useState(false);
  const [trueColor] = useState<string>(color ? color : getRandomColor());
  const [baseStyle, setBaseStyle] = useState<CSSProperties>({
    width: "100%",
    height: "100%",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyItems: "center",
    alignSelf: "center",
    animationDuration: "2.2s",
  });

  return (
    <div
      ref={rouletteDiv}
      className={" " + animate.animated + " " + animate.fadeIn}
      onAnimationEnd={() => {
        setRouletteStart(true);
        setVisible(true);
      }}
      style={baseStyle}
    >
      <div
        ref={heightDiv}
        className={styles["smooth-box"]}
        style={{
          width: "100%",
          margin: "0 auto",
          height: "100%",
          alignSelf: "center",
          position: "relative",
        }}
      >
        {visible && (
          <div
            style={{
              position: "absolute",
              top: "50%",
              left: "50%",
              width: "4px",
              height: `${heightDiv.current!.offsetHeight}px`,
              background: "orange",
              zIndex: 10,
              transform: "translate(-50%, -50%)",
              visibility: visible ? "visible" : "hidden",
            }}
          ></div>
        )}
        <RoulettePro
          start={rouletteStart}
          prizes={prizes}
          prizeIndex={rouletteIndex}
          spinningTime={20}
          type="horizontal"
          classes={{}}
          options={{ withoutAnimation: true }}
          defaultDesignOptions={{
            prizesWithText: true,
            hideCenterDelimiter: true,
          }}
          onPrizeDefined={() => {
            setVisible(false);
            const div = rouletteDiv.current!;
            div.onanimationend = () => {
              callback();
            };
            setBaseStyle((prev) => ({
              ...prev,
              animationDuration: "1.5s",
            }));
            div.className = " " + animate.animated + " " + animate.fadeOut;
          }}
        />
      </div>
      <div className={styles["roulette-name-text"]}>
        <span>рулетка</span>
        <span>для</span>
        <span style={{ color: trueColor }}>{name}</span>
      </div>
    </div>
  );
}
</file>

<file path="src/routes/ErrorPage.module.scss">
.error-page {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background-color: #f8f9fa;
  color: #343a40;
  text-align: center;
  padding: 20px;
  justify-self: center;
  align-self: center;
  width: 100%;

  .error-icon {
    font-size: 6rem;
    margin-bottom: 20px;
    color: #dc3545;
  }

  .error-title {
    font-size: 2.5rem;
    font-weight: bold;
    margin-bottom: 10px;
  }

  .error-description {
    font-size: 1.25rem;
    margin-bottom: 20px;
  }

  .error-button {
    padding: 10px 20px;
    font-size: 1rem;
    color: #fff;
    background-color: #007bff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;

    &:hover {
      background-color: #0056b3;
    }
  }
}
</file>

<file path="src/routes/ErrorPage.tsx">
import { IconType } from "react-icons"; // Предполагаем, что вы используете библиотеку react-icons для иконок

import styles from "./ErrorPage.module.scss"; // Импортируем стили

interface ErrorPageProps {
  typeError: string;
  icon?: IconType;
}

export const ErrorPage = ({ typeError, icon: Icon }: ErrorPageProps) => {
  const errorMessages: { [key: string]: string } = {
    "404": "Страница не найдена",
    "500": "Внутренняя ошибка сервера",
  };

  const message = errorMessages[typeError] || "Неизвестная ошибка";

  return (
    <div className={styles["error-page"]}>
      {Icon && <Icon className={styles["error-icon"]} />}
      <h1 className={styles["error-title"]}>{message}</h1>
      <p className={styles["error-description"]}>
        Простите, произошла ошибка. Пожалуйста, попробуйте позже.
      </p>
      <button
        className={styles["error-button"]}
        onClick={() => (window.location.pathname = "/")}
      >
        Перезагрузить страницу
      </button>
    </div>
  );
};

ErrorPage.displayName = "ErrorPage";
</file>

<file path="src/shared/components/KeyWordText/index.ts">
import { KeyWordedText } from "./KeyWordedText";
export { KeyWordedText as KeyWordText };
</file>

<file path="src/shared/components/PageName/PageName.tsx">
interface Props {
  title: string;
}

export default function PageName({ title }: Props) {
  document.title = title;

  return null;
}
</file>

<file path="src/shared/components/RainbowText/hsl2rgb.ts">
const ONE_SIXTH = 1 / 6;
const ONE_THIRD = 1 / 3;
const TWO_THIRDS = 2 / 3;

const hue2rgb = (p: number, q: number, t: number): number => {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < ONE_SIXTH) {
    return p + (q - p) * 6 * t;
  }
  if (t < 0.5) {
    return q;
  }
  if (t < TWO_THIRDS) {
    return p + (q - p) * (TWO_THIRDS - t) * 6;
  }
  return p;
};

const hsl2rgb = (h: number, s: number, l: number): number[] => {
  if (s === 0) {
    return [l, l, l];
  }
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  return [
    hue2rgb(p, q, h + ONE_THIRD),
    hue2rgb(p, q, h),
    hue2rgb(p, q, h - ONE_THIRD),
  ];
};

export default hsl2rgb;
</file>

<file path="src/shared/components/RainbowText/rainbowGradient.ts">
import hsl2rgb from "./hsl2rgb";

const rainbowGradient = (
  len: number,
  saturation: number = 1,
  lightness: number = 0.5,
): number[][] => {
  const gradient: number[][] = [];
  for (let x = 0; x < len; x++) {
    gradient.push(
      hsl2rgb(x / len, saturation, lightness).map((c) => Math.round(c * 255)),
    );
  }
  return gradient;
};

export default rainbowGradient;
</file>

<file path="src/shared/components/RainbowText/RainbowText.tsx">
import { useMemo } from "react";

import rainbowGradient from "./rainbowGradient";

interface RainbowTextProps {
  text: string;
  saturation?: number;
  lightness?: number;
  className?: string;
  style?: React.CSSProperties;
}

const RainbowText = ({
  text,
  saturation = 1,
  lightness = 0.5,
  className = "",
  style = {},
}: RainbowTextProps) => {
  const characters = useMemo(() => text.split(""), [text]);
  const gradientSize = useMemo(
    () => characters.filter((char) => char !== " ").length,
    [characters],
  );
  const gradient = useMemo(
    () => rainbowGradient(gradientSize, saturation, lightness),
    [gradientSize, saturation, lightness],
  );

  return (
    <span className={className} style={style}>
      {characters.map((char, index) => {
        if (char === " ") {
          return <span key={index}>{char}</span>;
        }

        return (
          <span
            key={index}
            style={{
              color: `rgb(${gradient[index % gradient.length].join(", ")})`,
              display: "inline-block",
              transition: "color 0.5s",
            }}
          >
            {char}
          </span>
        );
      })}
    </span>
  );
};

export default RainbowText;
</file>

<file path="src/shared/styles/animate.module.scss">
@charset "UTF-8";

/*!
 * Animate.css -http://daneden.me/animate
 * Version - 3.4.0
 * Licensed under the MIT license - http://opensource.org/licenses/MIT
 *
 * Copyright (c) 2015 Daniel Eden
 */

.animated {
    -webkit-animation-duration: 1s;
    -webkit-animation-fill-mode: both;
    animation-duration: 1s;
    animation-fill-mode: both;
}

.animated.infinite {
    -webkit-animation-iteration-count: infinite;
    animation-iteration-count: infinite;
}

.animated.hinge {
    -webkit-animation-duration: 2s;
    animation-duration: 2s;
}

.animated.flipOutX,
.animated.flipOutY,
.animated.bounceIn,
.animated.bounceOut {
    -webkit-animation-duration: .75s;
    animation-duration: .75s;
}

@-webkit-keyframes bounce {
    from, 20%, 53%, 80%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        -webkit-transform: translate3d(0, 0, 0);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        transform: translate3d(0, 0, 0);
    }

    40%, 43% {
        -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        -webkit-transform: translate3d(0, -30px, 0);
        animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        transform: translate3d(0, -30px, 0);
    }

    70% {
        -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        -webkit-transform: translate3d(0, -15px, 0);
        animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        transform: translate3d(0, -15px, 0);
    }

    90% {
        -webkit-transform: translate3d(0, -4px, 0);
        transform: translate3d(0, -4px, 0);
    }
}

@keyframes bounce {
    from, 20%, 53%, 80%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        -webkit-transform: translate3d(0, 0, 0);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        transform: translate3d(0, 0, 0);
    }

    40%, 43% {
        -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        -webkit-transform: translate3d(0, -30px, 0);
        animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        transform: translate3d(0, -30px, 0);
    }

    70% {
        -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        -webkit-transform: translate3d(0, -15px, 0);
        animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        transform: translate3d(0, -15px, 0);
    }

    90% {
        -webkit-transform: translate3d(0, -4px, 0);
        transform: translate3d(0, -4px, 0);
    }
}

.bounce {
    -webkit-animation-name: bounce;
    -webkit-transform-origin: center bottom;
    animation-name: bounce;
    transform-origin: center bottom;
}

@-webkit-keyframes flash {
    from, 50%, to { opacity: 1; }

    25%, 75% { opacity: 0; }
}

@keyframes flash {
    from, 50%, to { opacity: 1; }

    25%, 75% { opacity: 0; }
}

.flash {
    -webkit-animation-name: flash;
    animation-name: flash;
}

/* originally authored by Nick Pettit - https://github.com/nickpettit/glide */

@-webkit-keyframes pulse {
    from {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }

    50% {
        -webkit-transform: scale3d(1.05, 1.05, 1.05);
        transform: scale3d(1.05, 1.05, 1.05);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }
}

@keyframes pulse {
    from {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }

    50% {
        -webkit-transform: scale3d(1.05, 1.05, 1.05);
        transform: scale3d(1.05, 1.05, 1.05);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }
}

.pulse {
    -webkit-animation-name: pulse;
    animation-name: pulse;
}

@-webkit-keyframes rubberBand {
    from {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }

    30% {
        -webkit-transform: scale3d(1.25, 0.75, 1);
        transform: scale3d(1.25, 0.75, 1);
    }

    40% {
        -webkit-transform: scale3d(0.75, 1.25, 1);
        transform: scale3d(0.75, 1.25, 1);
    }

    50% {
        -webkit-transform: scale3d(1.15, 0.85, 1);
        transform: scale3d(1.15, 0.85, 1);
    }

    65% {
        -webkit-transform: scale3d(.95, 1.05, 1);
        transform: scale3d(.95, 1.05, 1);
    }

    75% {
        -webkit-transform: scale3d(1.05, .95, 1);
        transform: scale3d(1.05, .95, 1);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }
}

@keyframes rubberBand {
    from {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }

    30% {
        -webkit-transform: scale3d(1.25, 0.75, 1);
        transform: scale3d(1.25, 0.75, 1);
    }

    40% {
        -webkit-transform: scale3d(0.75, 1.25, 1);
        transform: scale3d(0.75, 1.25, 1);
    }

    50% {
        -webkit-transform: scale3d(1.15, 0.85, 1);
        transform: scale3d(1.15, 0.85, 1);
    }

    65% {
        -webkit-transform: scale3d(.95, 1.05, 1);
        transform: scale3d(.95, 1.05, 1);
    }

    75% {
        -webkit-transform: scale3d(1.05, .95, 1);
        transform: scale3d(1.05, .95, 1);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }
}

.rubberBand {
    -webkit-animation-name: rubberBand;
    animation-name: rubberBand;
}

@-webkit-keyframes shake {
    from, to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    10%, 30%, 50%, 70%, 90% {
        -webkit-transform: translate3d(-10px, 0, 0);
        transform: translate3d(-10px, 0, 0);
    }

    20%, 40%, 60%, 80% {
        -webkit-transform: translate3d(10px, 0, 0);
        transform: translate3d(10px, 0, 0);
    }
}

@keyframes shake {
    from, to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    10%, 30%, 50%, 70%, 90% {
        -webkit-transform: translate3d(-10px, 0, 0);
        transform: translate3d(-10px, 0, 0);
    }

    20%, 40%, 60%, 80% {
        -webkit-transform: translate3d(10px, 0, 0);
        transform: translate3d(10px, 0, 0);
    }
}

.shake {
    -webkit-animation-name: shake;
    animation-name: shake;
}

@-webkit-keyframes headShake {
    0% {
        -webkit-transform: translateX(0);
        transform: translateX(0);
    }

    6.5% {
        -webkit-transform: translateX(-6px) rotateY(-9deg);
        transform: translateX(-6px) rotateY(-9deg);
    }

    18.5% {
        -webkit-transform: translateX(5px) rotateY(7deg);
        transform: translateX(5px) rotateY(7deg);
    }

    31.5% {
        -webkit-transform: translateX(-3px) rotateY(-5deg);
        transform: translateX(-3px) rotateY(-5deg);
    }

    43.5% {
        -webkit-transform: translateX(2px) rotateY(3deg);
        transform: translateX(2px) rotateY(3deg);
    }

    50% {
        -webkit-transform: translateX(0);
        transform: translateX(0);
    }
}

@keyframes headShake {
    0% {
        -webkit-transform: translateX(0);
        transform: translateX(0);
    }

    6.5% {
        -webkit-transform: translateX(-6px) rotateY(-9deg);
        transform: translateX(-6px) rotateY(-9deg);
    }

    18.5% {
        -webkit-transform: translateX(5px) rotateY(7deg);
        transform: translateX(5px) rotateY(7deg);
    }

    31.5% {
        -webkit-transform: translateX(-3px) rotateY(-5deg);
        transform: translateX(-3px) rotateY(-5deg);
    }

    43.5% {
        -webkit-transform: translateX(2px) rotateY(3deg);
        transform: translateX(2px) rotateY(3deg);
    }

    50% {
        -webkit-transform: translateX(0);
        transform: translateX(0);
    }
}

.headShake {
    -webkit-animation-name: headShake;
    -webkit-animation-timing-function: ease-in-out;
    animation-name: headShake;
    animation-timing-function: ease-in-out;
}

@-webkit-keyframes swing {
    20% {
        -webkit-transform: rotate3d(0, 0, 1, 15deg);
        transform: rotate3d(0, 0, 1, 15deg);
    }

    40% {
        -webkit-transform: rotate3d(0, 0, 1, -10deg);
        transform: rotate3d(0, 0, 1, -10deg);
    }

    60% {
        -webkit-transform: rotate3d(0, 0, 1, 5deg);
        transform: rotate3d(0, 0, 1, 5deg);
    }

    80% {
        -webkit-transform: rotate3d(0, 0, 1, -5deg);
        transform: rotate3d(0, 0, 1, -5deg);
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, 0deg);
        transform: rotate3d(0, 0, 1, 0deg);
    }
}

@keyframes swing {
    20% {
        -webkit-transform: rotate3d(0, 0, 1, 15deg);
        transform: rotate3d(0, 0, 1, 15deg);
    }

    40% {
        -webkit-transform: rotate3d(0, 0, 1, -10deg);
        transform: rotate3d(0, 0, 1, -10deg);
    }

    60% {
        -webkit-transform: rotate3d(0, 0, 1, 5deg);
        transform: rotate3d(0, 0, 1, 5deg);
    }

    80% {
        -webkit-transform: rotate3d(0, 0, 1, -5deg);
        transform: rotate3d(0, 0, 1, -5deg);
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, 0deg);
        transform: rotate3d(0, 0, 1, 0deg);
    }
}

.swing {
    -webkit-animation-name: swing;
    -webkit-transform-origin: top center;
    animation-name: swing;
    transform-origin: top center;
}

@-webkit-keyframes tada {
    from {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }

    10%, 20% {
        -webkit-transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
        transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
    }

    30%, 50%, 70%, 90% {
        -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
        transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
    }

    40%, 60%, 80% {
        -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
        transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }
}

@keyframes tada {
    from {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }

    10%, 20% {
        -webkit-transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
        transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
    }

    30%, 50%, 70%, 90% {
        -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
        transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
    }

    40%, 60%, 80% {
        -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
        transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }
}

.tada {
    -webkit-animation-name: tada;
    animation-name: tada;
}

/* originally authored by Nick Pettit - https://github.com/nickpettit/glide */

@-webkit-keyframes wobble {
    from {
        -webkit-transform: none;
        transform: none;
    }

    15% {
        -webkit-transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
        transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
    }

    30% {
        -webkit-transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
        transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
    }

    45% {
        -webkit-transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
        transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
    }

    60% {
        -webkit-transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
        transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
    }

    75% {
        -webkit-transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
        transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
    }

    to {
        -webkit-transform: none;
        transform: none;
    }
}

@keyframes wobble {
    from {
        -webkit-transform: none;
        transform: none;
    }

    15% {
        -webkit-transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
        transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
    }

    30% {
        -webkit-transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
        transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
    }

    45% {
        -webkit-transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
        transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
    }

    60% {
        -webkit-transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
        transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
    }

    75% {
        -webkit-transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
        transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
    }

    to {
        -webkit-transform: none;
        transform: none;
    }
}

.wobble {
    -webkit-animation-name: wobble;
    animation-name: wobble;
}

@-webkit-keyframes jello {
    from, 11.1%, to {
        -webkit-transform: none;
        transform: none;
    }

    22.2% {
        -webkit-transform: skewX(-12.5deg) skewY(-12.5deg);
        transform: skewX(-12.5deg) skewY(-12.5deg);
    }

    33.3% {
        -webkit-transform: skewX(6.25deg) skewY(6.25deg);
        transform: skewX(6.25deg) skewY(6.25deg);
    }

    44.4% {
        -webkit-transform: skewX(-3.125deg) skewY(-3.125deg);
        transform: skewX(-3.125deg) skewY(-3.125deg);
    }

    55.5% {
        -webkit-transform: skewX(1.5625deg) skewY(1.5625deg);
        transform: skewX(1.5625deg) skewY(1.5625deg);
    }

    66.6% {
        -webkit-transform: skewX(-0.78125deg) skewY(-0.78125deg);
        transform: skewX(-0.78125deg) skewY(-0.78125deg);
    }

    77.7% {
        -webkit-transform: skewX(0.390625deg) skewY(0.390625deg);
        transform: skewX(0.390625deg) skewY(0.390625deg);
    }

    88.8% {
        -webkit-transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
        transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
    }
}

@keyframes jello {
    from, 11.1%, to {
        -webkit-transform: none;
        transform: none;
    }

    22.2% {
        -webkit-transform: skewX(-12.5deg) skewY(-12.5deg);
        transform: skewX(-12.5deg) skewY(-12.5deg);
    }

    33.3% {
        -webkit-transform: skewX(6.25deg) skewY(6.25deg);
        transform: skewX(6.25deg) skewY(6.25deg);
    }

    44.4% {
        -webkit-transform: skewX(-3.125deg) skewY(-3.125deg);
        transform: skewX(-3.125deg) skewY(-3.125deg);
    }

    55.5% {
        -webkit-transform: skewX(1.5625deg) skewY(1.5625deg);
        transform: skewX(1.5625deg) skewY(1.5625deg);
    }

    66.6% {
        -webkit-transform: skewX(-0.78125deg) skewY(-0.78125deg);
        transform: skewX(-0.78125deg) skewY(-0.78125deg);
    }

    77.7% {
        -webkit-transform: skewX(0.390625deg) skewY(0.390625deg);
        transform: skewX(0.390625deg) skewY(0.390625deg);
    }

    88.8% {
        -webkit-transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
        transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
    }
}

.jello {
    -webkit-animation-name: jello;
    -webkit-transform-origin: center;
    animation-name: jello;
    transform-origin: center;
}

@-webkit-keyframes bounceIn {
    from, 20%, 40%, 60%, 80%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    0% {
        -webkit-transform: scale3d(.3, .3, .3);
        opacity: 0;
        transform: scale3d(.3, .3, .3);
    }

    20% {
        -webkit-transform: scale3d(1.1, 1.1, 1.1);
        transform: scale3d(1.1, 1.1, 1.1);
    }

    40% {
        -webkit-transform: scale3d(.9, .9, .9);
        transform: scale3d(.9, .9, .9);
    }

    60% {
        -webkit-transform: scale3d(1.03, 1.03, 1.03);
        opacity: 1;
        transform: scale3d(1.03, 1.03, 1.03);
    }

    80% {
        -webkit-transform: scale3d(.97, .97, .97);
        transform: scale3d(.97, .97, .97);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        opacity: 1;
        transform: scale3d(1, 1, 1);
    }
}

@keyframes bounceIn {
    from, 20%, 40%, 60%, 80%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    0% {
        -webkit-transform: scale3d(.3, .3, .3);
        opacity: 0;
        transform: scale3d(.3, .3, .3);
    }

    20% {
        -webkit-transform: scale3d(1.1, 1.1, 1.1);
        transform: scale3d(1.1, 1.1, 1.1);
    }

    40% {
        -webkit-transform: scale3d(.9, .9, .9);
        transform: scale3d(.9, .9, .9);
    }

    60% {
        -webkit-transform: scale3d(1.03, 1.03, 1.03);
        opacity: 1;
        transform: scale3d(1.03, 1.03, 1.03);
    }

    80% {
        -webkit-transform: scale3d(.97, .97, .97);
        transform: scale3d(.97, .97, .97);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        opacity: 1;
        transform: scale3d(1, 1, 1);
    }
}

.bounceIn {
    -webkit-animation-name: bounceIn;
    animation-name: bounceIn;
}

@-webkit-keyframes bounceInDown {
    from, 60%, 75%, 90%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    0% {
        -webkit-transform: translate3d(0, -3000px, 0);
        opacity: 0;
        transform: translate3d(0, -3000px, 0);
    }

    60% {
        -webkit-transform: translate3d(0, 25px, 0);
        opacity: 1;
        transform: translate3d(0, 25px, 0);
    }

    75% {
        -webkit-transform: translate3d(0, -10px, 0);
        transform: translate3d(0, -10px, 0);
    }

    90% {
        -webkit-transform: translate3d(0, 5px, 0);
        transform: translate3d(0, 5px, 0);
    }

    to {
        -webkit-transform: none;
        transform: none;
    }
}

@keyframes bounceInDown {
    from, 60%, 75%, 90%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    0% {
        -webkit-transform: translate3d(0, -3000px, 0);
        opacity: 0;
        transform: translate3d(0, -3000px, 0);
    }

    60% {
        -webkit-transform: translate3d(0, 25px, 0);
        opacity: 1;
        transform: translate3d(0, 25px, 0);
    }

    75% {
        -webkit-transform: translate3d(0, -10px, 0);
        transform: translate3d(0, -10px, 0);
    }

    90% {
        -webkit-transform: translate3d(0, 5px, 0);
        transform: translate3d(0, 5px, 0);
    }

    to {
        -webkit-transform: none;
        transform: none;
    }
}

.bounceInDown {
    -webkit-animation-name: bounceInDown;
    animation-name: bounceInDown;
}

@-webkit-keyframes bounceInLeft {
    from, 60%, 75%, 90%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    0% {
        -webkit-transform: translate3d(-3000px, 0, 0);
        opacity: 0;
        transform: translate3d(-3000px, 0, 0);
    }

    60% {
        -webkit-transform: translate3d(25px, 0, 0);
        opacity: 1;
        transform: translate3d(25px, 0, 0);
    }

    75% {
        -webkit-transform: translate3d(-10px, 0, 0);
        transform: translate3d(-10px, 0, 0);
    }

    90% {
        -webkit-transform: translate3d(5px, 0, 0);
        transform: translate3d(5px, 0, 0);
    }

    to {
        -webkit-transform: none;
        transform: none;
    }
}

@keyframes bounceInLeft {
    from, 60%, 75%, 90%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    0% {
        -webkit-transform: translate3d(-3000px, 0, 0);
        opacity: 0;
        transform: translate3d(-3000px, 0, 0);
    }

    60% {
        -webkit-transform: translate3d(25px, 0, 0);
        opacity: 1;
        transform: translate3d(25px, 0, 0);
    }

    75% {
        -webkit-transform: translate3d(-10px, 0, 0);
        transform: translate3d(-10px, 0, 0);
    }

    90% {
        -webkit-transform: translate3d(5px, 0, 0);
        transform: translate3d(5px, 0, 0);
    }

    to {
        -webkit-transform: none;
        transform: none;
    }
}

.bounceInLeft {
    -webkit-animation-name: bounceInLeft;
    animation-name: bounceInLeft;
}

@-webkit-keyframes bounceInRight {
    from, 60%, 75%, 90%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    from {
        -webkit-transform: translate3d(3000px, 0, 0);
        opacity: 0;
        transform: translate3d(3000px, 0, 0);
    }

    60% {
        -webkit-transform: translate3d(-25px, 0, 0);
        opacity: 1;
        transform: translate3d(-25px, 0, 0);
    }

    75% {
        -webkit-transform: translate3d(10px, 0, 0);
        transform: translate3d(10px, 0, 0);
    }

    90% {
        -webkit-transform: translate3d(-5px, 0, 0);
        transform: translate3d(-5px, 0, 0);
    }

    to {
        -webkit-transform: none;
        transform: none;
    }
}

@keyframes bounceInRight {
    from, 60%, 75%, 90%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    from {
        -webkit-transform: translate3d(3000px, 0, 0);
        opacity: 0;
        transform: translate3d(3000px, 0, 0);
    }

    60% {
        -webkit-transform: translate3d(-25px, 0, 0);
        opacity: 1;
        transform: translate3d(-25px, 0, 0);
    }

    75% {
        -webkit-transform: translate3d(10px, 0, 0);
        transform: translate3d(10px, 0, 0);
    }

    90% {
        -webkit-transform: translate3d(-5px, 0, 0);
        transform: translate3d(-5px, 0, 0);
    }

    to {
        -webkit-transform: none;
        transform: none;
    }
}

.bounceInRight {
    -webkit-animation-name: bounceInRight;
    animation-name: bounceInRight;
}

@-webkit-keyframes bounceInUp {
    from, 60%, 75%, 90%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    from {
        -webkit-transform: translate3d(0, 3000px, 0);
        opacity: 0;
        transform: translate3d(0, 3000px, 0);
    }

    60% {
        -webkit-transform: translate3d(0, -20px, 0);
        opacity: 1;
        transform: translate3d(0, -20px, 0);
    }

    75% {
        -webkit-transform: translate3d(0, 10px, 0);
        transform: translate3d(0, 10px, 0);
    }

    90% {
        -webkit-transform: translate3d(0, -5px, 0);
        transform: translate3d(0, -5px, 0);
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

@keyframes bounceInUp {
    from, 60%, 75%, 90%, to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    from {
        -webkit-transform: translate3d(0, 3000px, 0);
        opacity: 0;
        transform: translate3d(0, 3000px, 0);
    }

    60% {
        -webkit-transform: translate3d(0, -20px, 0);
        opacity: 1;
        transform: translate3d(0, -20px, 0);
    }

    75% {
        -webkit-transform: translate3d(0, 10px, 0);
        transform: translate3d(0, 10px, 0);
    }

    90% {
        -webkit-transform: translate3d(0, -5px, 0);
        transform: translate3d(0, -5px, 0);
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

.bounceInUp {
    -webkit-animation-name: bounceInUp;
    animation-name: bounceInUp;
}

@-webkit-keyframes bounceOut {
    20% {
        -webkit-transform: scale3d(.9, .9, .9);
        transform: scale3d(.9, .9, .9);
    }

    50%, 55% {
        -webkit-transform: scale3d(1.1, 1.1, 1.1);
        opacity: 1;
        transform: scale3d(1.1, 1.1, 1.1);
    }

    to {
        -webkit-transform: scale3d(.3, .3, .3);
        opacity: 0;
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes bounceOut {
    20% {
        -webkit-transform: scale3d(.9, .9, .9);
        transform: scale3d(.9, .9, .9);
    }

    50%, 55% {
        -webkit-transform: scale3d(1.1, 1.1, 1.1);
        opacity: 1;
        transform: scale3d(1.1, 1.1, 1.1);
    }

    to {
        -webkit-transform: scale3d(.3, .3, .3);
        opacity: 0;
        transform: scale3d(.3, .3, .3);
    }
}

.bounceOut {
    -webkit-animation-name: bounceOut;
    animation-name: bounceOut;
}

@-webkit-keyframes bounceOutDown {
    20% {
        -webkit-transform: translate3d(0, 10px, 0);
        transform: translate3d(0, 10px, 0);
    }

    40%, 45% {
        -webkit-transform: translate3d(0, -20px, 0);
        opacity: 1;
        transform: translate3d(0, -20px, 0);
    }

    to {
        -webkit-transform: translate3d(0, 2000px, 0);
        opacity: 0;
        transform: translate3d(0, 2000px, 0);
    }
}

@keyframes bounceOutDown {
    20% {
        -webkit-transform: translate3d(0, 10px, 0);
        transform: translate3d(0, 10px, 0);
    }

    40%, 45% {
        -webkit-transform: translate3d(0, -20px, 0);
        opacity: 1;
        transform: translate3d(0, -20px, 0);
    }

    to {
        -webkit-transform: translate3d(0, 2000px, 0);
        opacity: 0;
        transform: translate3d(0, 2000px, 0);
    }
}

.bounceOutDown {
    -webkit-animation-name: bounceOutDown;
    animation-name: bounceOutDown;
}

@-webkit-keyframes bounceOutLeft {
    20% {
        -webkit-transform: translate3d(20px, 0, 0);
        opacity: 1;
        transform: translate3d(20px, 0, 0);
    }

    to {
        -webkit-transform: translate3d(-2000px, 0, 0);
        opacity: 0;
        transform: translate3d(-2000px, 0, 0);
    }
}

@keyframes bounceOutLeft {
    20% {
        -webkit-transform: translate3d(20px, 0, 0);
        opacity: 1;
        transform: translate3d(20px, 0, 0);
    }

    to {
        -webkit-transform: translate3d(-2000px, 0, 0);
        opacity: 0;
        transform: translate3d(-2000px, 0, 0);
    }
}

.bounceOutLeft {
    -webkit-animation-name: bounceOutLeft;
    animation-name: bounceOutLeft;
}

@-webkit-keyframes bounceOutRight {
    20% {
        -webkit-transform: translate3d(-20px, 0, 0);
        opacity: 1;
        transform: translate3d(-20px, 0, 0);
    }

    to {
        -webkit-transform: translate3d(2000px, 0, 0);
        opacity: 0;
        transform: translate3d(2000px, 0, 0);
    }
}

@keyframes bounceOutRight {
    20% {
        -webkit-transform: translate3d(-20px, 0, 0);
        opacity: 1;
        transform: translate3d(-20px, 0, 0);
    }

    to {
        -webkit-transform: translate3d(2000px, 0, 0);
        opacity: 0;
        transform: translate3d(2000px, 0, 0);
    }
}

.bounceOutRight {
    -webkit-animation-name: bounceOutRight;
    animation-name: bounceOutRight;
}

@-webkit-keyframes bounceOutUp {
    20% {
        -webkit-transform: translate3d(0, -10px, 0);
        transform: translate3d(0, -10px, 0);
    }

    40%, 45% {
        -webkit-transform: translate3d(0, 20px, 0);
        opacity: 1;
        transform: translate3d(0, 20px, 0);
    }

    to {
        -webkit-transform: translate3d(0, -2000px, 0);
        opacity: 0;
        transform: translate3d(0, -2000px, 0);
    }
}

@keyframes bounceOutUp {
    20% {
        -webkit-transform: translate3d(0, -10px, 0);
        transform: translate3d(0, -10px, 0);
    }

    40%, 45% {
        -webkit-transform: translate3d(0, 20px, 0);
        opacity: 1;
        transform: translate3d(0, 20px, 0);
    }

    to {
        -webkit-transform: translate3d(0, -2000px, 0);
        opacity: 0;
        transform: translate3d(0, -2000px, 0);
    }
}

.bounceOutUp {
    -webkit-animation-name: bounceOutUp;
    animation-name: bounceOutUp;
}

@-webkit-keyframes fadeIn {
    from { opacity: 0; }

    to { opacity: 1; }
}

@keyframes fadeIn {
    from { opacity: 0; }

    to { opacity: 1; }
}

.fadeIn {
    -webkit-animation-name: fadeIn;
    animation-name: fadeIn;
}

@-webkit-keyframes fadeInDown {
    from {
        -webkit-transform: translate3d(0, -100%, 0);
        opacity: 0;
        transform: translate3d(0, -100%, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes fadeInDown {
    from {
        -webkit-transform: translate3d(0, -100%, 0);
        opacity: 0;
        transform: translate3d(0, -100%, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.fadeInDown {
    -webkit-animation-name: fadeInDown;
    animation-name: fadeInDown;
}

@-webkit-keyframes fadeInDownBig {
    from {
        -webkit-transform: translate3d(0, -2000px, 0);
        opacity: 0;
        transform: translate3d(0, -2000px, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes fadeInDownBig {
    from {
        -webkit-transform: translate3d(0, -2000px, 0);
        opacity: 0;
        transform: translate3d(0, -2000px, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.fadeInDownBig {
    -webkit-animation-name: fadeInDownBig;
    animation-name: fadeInDownBig;
}

@-webkit-keyframes fadeInLeft {
    from {
        -webkit-transform: translate3d(-100%, 0, 0);
        opacity: 0;
        transform: translate3d(-100%, 0, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes fadeInLeft {
    from {
        -webkit-transform: translate3d(-100%, 0, 0);
        opacity: 0;
        transform: translate3d(-100%, 0, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.fadeInLeft {
    -webkit-animation-name: fadeInLeft;
    animation-name: fadeInLeft;
}

@-webkit-keyframes fadeInLeftBig {
    from {
        -webkit-transform: translate3d(-2000px, 0, 0);
        opacity: 0;
        transform: translate3d(-2000px, 0, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes fadeInLeftBig {
    from {
        -webkit-transform: translate3d(-2000px, 0, 0);
        opacity: 0;
        transform: translate3d(-2000px, 0, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.fadeInLeftBig {
    -webkit-animation-name: fadeInLeftBig;
    animation-name: fadeInLeftBig;
}

@-webkit-keyframes fadeInRight {
    from {
        -webkit-transform: translate3d(100%, 0, 0);
        opacity: 0;
        transform: translate3d(100%, 0, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes fadeInRight {
    from {
        -webkit-transform: translate3d(100%, 0, 0);
        opacity: 0;
        transform: translate3d(100%, 0, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.fadeInRight {
    -webkit-animation-name: fadeInRight;
    animation-name: fadeInRight;
}

@-webkit-keyframes fadeInRightBig {
    from {
        -webkit-transform: translate3d(2000px, 0, 0);
        opacity: 0;
        transform: translate3d(2000px, 0, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes fadeInRightBig {
    from {
        -webkit-transform: translate3d(2000px, 0, 0);
        opacity: 0;
        transform: translate3d(2000px, 0, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.fadeInRightBig {
    -webkit-animation-name: fadeInRightBig;
    animation-name: fadeInRightBig;
}

@-webkit-keyframes fadeInUp {
    from {
        -webkit-transform: translate3d(0, 100%, 0);
        opacity: 0;
        transform: translate3d(0, 100%, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes fadeInUp {
    from {
        -webkit-transform: translate3d(0, 100%, 0);
        opacity: 0;
        transform: translate3d(0, 100%, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.fadeInUp {
    -webkit-animation-name: fadeInUp;
    animation-name: fadeInUp;
}

@-webkit-keyframes fadeInUpBig {
    from {
        -webkit-transform: translate3d(0, 2000px, 0);
        opacity: 0;
        transform: translate3d(0, 2000px, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes fadeInUpBig {
    from {
        -webkit-transform: translate3d(0, 2000px, 0);
        opacity: 0;
        transform: translate3d(0, 2000px, 0);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.fadeInUpBig {
    -webkit-animation-name: fadeInUpBig;
    animation-name: fadeInUpBig;
}

@-webkit-keyframes fadeOut {
    from { opacity: 1; }

    to { opacity: 0; }
}

@keyframes fadeOut {
    from { opacity: 1; }

    to { opacity: 0; }
}

.fadeOut {
    -webkit-animation-name: fadeOut;
    animation-name: fadeOut;
}

@-webkit-keyframes fadeOutDown {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(0, 100%, 0);
        opacity: 0;
        transform: translate3d(0, 100%, 0);
    }
}

@keyframes fadeOutDown {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(0, 100%, 0);
        opacity: 0;
        transform: translate3d(0, 100%, 0);
    }
}

.fadeOutDown {
    -webkit-animation-name: fadeOutDown;
    animation-name: fadeOutDown;
}

@-webkit-keyframes fadeOutDownBig {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(0, 2000px, 0);
        opacity: 0;
        transform: translate3d(0, 2000px, 0);
    }
}

@keyframes fadeOutDownBig {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(0, 2000px, 0);
        opacity: 0;
        transform: translate3d(0, 2000px, 0);
    }
}

.fadeOutDownBig {
    -webkit-animation-name: fadeOutDownBig;
    animation-name: fadeOutDownBig;
}

@-webkit-keyframes fadeOutLeft {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(-100%, 0, 0);
        opacity: 0;
        transform: translate3d(-100%, 0, 0);
    }
}

@keyframes fadeOutLeft {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(-100%, 0, 0);
        opacity: 0;
        transform: translate3d(-100%, 0, 0);
    }
}

.fadeOutLeft {
    -webkit-animation-name: fadeOutLeft;
    animation-name: fadeOutLeft;
}

@-webkit-keyframes fadeOutLeftBig {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(-2000px, 0, 0);
        opacity: 0;
        transform: translate3d(-2000px, 0, 0);
    }
}

@keyframes fadeOutLeftBig {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(-2000px, 0, 0);
        opacity: 0;
        transform: translate3d(-2000px, 0, 0);
    }
}

.fadeOutLeftBig {
    -webkit-animation-name: fadeOutLeftBig;
    animation-name: fadeOutLeftBig;
}

@-webkit-keyframes fadeOutRight {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(100%, 0, 0);
        opacity: 0;
        transform: translate3d(100%, 0, 0);
    }
}

@keyframes fadeOutRight {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(100%, 0, 0);
        opacity: 0;
        transform: translate3d(100%, 0, 0);
    }
}

.fadeOutRight {
    -webkit-animation-name: fadeOutRight;
    animation-name: fadeOutRight;
}

@-webkit-keyframes fadeOutRightBig {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(2000px, 0, 0);
        opacity: 0;
        transform: translate3d(2000px, 0, 0);
    }
}

@keyframes fadeOutRightBig {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(2000px, 0, 0);
        opacity: 0;
        transform: translate3d(2000px, 0, 0);
    }
}

.fadeOutRightBig {
    -webkit-animation-name: fadeOutRightBig;
    animation-name: fadeOutRightBig;
}

@-webkit-keyframes fadeOutUp {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(0, -100%, 0);
        opacity: 0;
        transform: translate3d(0, -100%, 0);
    }
}

@keyframes fadeOutUp {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(0, -100%, 0);
        opacity: 0;
        transform: translate3d(0, -100%, 0);
    }
}

.fadeOutUp {
    -webkit-animation-name: fadeOutUp;
    animation-name: fadeOutUp;
}

@-webkit-keyframes fadeOutUpBig {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(0, -2000px, 0);
        opacity: 0;
        transform: translate3d(0, -2000px, 0);
    }
}

@keyframes fadeOutUpBig {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(0, -2000px, 0);
        opacity: 0;
        transform: translate3d(0, -2000px, 0);
    }
}

.fadeOutUpBig {
    -webkit-animation-name: fadeOutUpBig;
    animation-name: fadeOutUpBig;
}

@-webkit-keyframes flip {
    from {
        -webkit-animation-timing-function: ease-out;
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
        animation-timing-function: ease-out;
        transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
    }

    40% {
        -webkit-animation-timing-function: ease-out;
        -webkit-transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
        animation-timing-function: ease-out;
        transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
    }

    50% {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
        animation-timing-function: ease-in;
        transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
    }

    80% {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) scale3d(.95, .95, .95);
        animation-timing-function: ease-in;
        transform: perspective(400px) scale3d(.95, .95, .95);
    }

    to {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px);
        animation-timing-function: ease-in;
        transform: perspective(400px);
    }
}

@keyframes flip {
    from {
        -webkit-animation-timing-function: ease-out;
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
        animation-timing-function: ease-out;
        transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
    }

    40% {
        -webkit-animation-timing-function: ease-out;
        -webkit-transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
        animation-timing-function: ease-out;
        transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
    }

    50% {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
        animation-timing-function: ease-in;
        transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
    }

    80% {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) scale3d(.95, .95, .95);
        animation-timing-function: ease-in;
        transform: perspective(400px) scale3d(.95, .95, .95);
    }

    to {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px);
        animation-timing-function: ease-in;
        transform: perspective(400px);
    }
}

.animated.flip {
    -webkit-animation-name: flip;
    -webkit-backface-visibility: visible;
    animation-name: flip;
    backface-visibility: visible;
}

@-webkit-keyframes flipInX {
    from {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
        animation-timing-function: ease-in;
        opacity: 0;
        transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    }

    40% {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
        animation-timing-function: ease-in;
        transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    }

    60% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
        opacity: 1;
        transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    }

    80% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

@keyframes flipInX {
    from {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
        animation-timing-function: ease-in;
        opacity: 0;
        transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    }

    40% {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
        animation-timing-function: ease-in;
        transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    }

    60% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
        opacity: 1;
        transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    }

    80% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

.flipInX {
    -webkit-animation-name: flipInX;
    -webkit-backface-visibility: visible !important;
    animation-name: flipInX;
    backface-visibility: visible !important;
}

@-webkit-keyframes flipInY {
    from {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
        animation-timing-function: ease-in;
        opacity: 0;
        transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    }

    40% {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
        animation-timing-function: ease-in;
        transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
    }

    60% {
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
        opacity: 1;
        transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
    }

    80% {
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
        transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

@keyframes flipInY {
    from {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
        animation-timing-function: ease-in;
        opacity: 0;
        transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    }

    40% {
        -webkit-animation-timing-function: ease-in;
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
        animation-timing-function: ease-in;
        transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
    }

    60% {
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
        opacity: 1;
        transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
    }

    80% {
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
        transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

.flipInY {
    -webkit-animation-name: flipInY;
    -webkit-backface-visibility: visible !important;
    animation-name: flipInY;
    backface-visibility: visible !important;
}

@-webkit-keyframes flipOutX {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
        opacity: 1;
        transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
        opacity: 0;
        transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    }
}

@keyframes flipOutX {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
        opacity: 1;
        transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
        opacity: 0;
        transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    }
}

.flipOutX {
    -webkit-animation-name: flipOutX;
    -webkit-backface-visibility: visible !important;
    animation-name: flipOutX;
    backface-visibility: visible !important;
}

@-webkit-keyframes flipOutY {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
        opacity: 1;
        transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
        opacity: 0;
        transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    }
}

@keyframes flipOutY {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
        opacity: 1;
        transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
        opacity: 0;
        transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    }
}

.flipOutY {
    -webkit-animation-name: flipOutY;
    -webkit-backface-visibility: visible !important;
    animation-name: flipOutY;
    backface-visibility: visible !important;
}

@-webkit-keyframes lightSpeedIn {
    from {
        -webkit-transform: translate3d(100%, 0, 0) skewX(-30deg);
        opacity: 0;
        transform: translate3d(100%, 0, 0) skewX(-30deg);
    }

    60% {
        -webkit-transform: skewX(20deg);
        opacity: 1;
        transform: skewX(20deg);
    }

    80% {
        -webkit-transform: skewX(-5deg);
        opacity: 1;
        transform: skewX(-5deg);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes lightSpeedIn {
    from {
        -webkit-transform: translate3d(100%, 0, 0) skewX(-30deg);
        opacity: 0;
        transform: translate3d(100%, 0, 0) skewX(-30deg);
    }

    60% {
        -webkit-transform: skewX(20deg);
        opacity: 1;
        transform: skewX(20deg);
    }

    80% {
        -webkit-transform: skewX(-5deg);
        opacity: 1;
        transform: skewX(-5deg);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.lightSpeedIn {
    -webkit-animation-name: lightSpeedIn;
    -webkit-animation-timing-function: ease-out;
    animation-name: lightSpeedIn;
    animation-timing-function: ease-out;
}

@-webkit-keyframes lightSpeedOut {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(100%, 0, 0) skewX(30deg);
        opacity: 0;
        transform: translate3d(100%, 0, 0) skewX(30deg);
    }
}

@keyframes lightSpeedOut {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(100%, 0, 0) skewX(30deg);
        opacity: 0;
        transform: translate3d(100%, 0, 0) skewX(30deg);
    }
}

.lightSpeedOut {
    -webkit-animation-name: lightSpeedOut;
    -webkit-animation-timing-function: ease-in;
    animation-name: lightSpeedOut;
    animation-timing-function: ease-in;
}

@-webkit-keyframes rotateIn {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -200deg);
        -webkit-transform-origin: center;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -200deg);
        transform-origin: center;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: center;
        opacity: 1;
        transform: none;
        transform-origin: center;
    }
}

@keyframes rotateIn {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -200deg);
        -webkit-transform-origin: center;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -200deg);
        transform-origin: center;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: center;
        opacity: 1;
        transform: none;
        transform-origin: center;
    }
}

.rotateIn {
    -webkit-animation-name: rotateIn;
    animation-name: rotateIn;
}

@-webkit-keyframes rotateInDownLeft {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -45deg);
        -webkit-transform-origin: left bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -45deg);
        transform-origin: left bottom;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: left bottom;
        opacity: 1;
        transform: none;
        transform-origin: left bottom;
    }
}

@keyframes rotateInDownLeft {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -45deg);
        -webkit-transform-origin: left bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -45deg);
        transform-origin: left bottom;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: left bottom;
        opacity: 1;
        transform: none;
        transform-origin: left bottom;
    }
}

.rotateInDownLeft {
    -webkit-animation-name: rotateInDownLeft;
    animation-name: rotateInDownLeft;
}

@-webkit-keyframes rotateInDownRight {
    from {
        -webkit-transform: rotate3d(0, 0, 1, 45deg);
        -webkit-transform-origin: right bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 45deg);
        transform-origin: right bottom;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: right bottom;
        opacity: 1;
        transform: none;
        transform-origin: right bottom;
    }
}

@keyframes rotateInDownRight {
    from {
        -webkit-transform: rotate3d(0, 0, 1, 45deg);
        -webkit-transform-origin: right bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 45deg);
        transform-origin: right bottom;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: right bottom;
        opacity: 1;
        transform: none;
        transform-origin: right bottom;
    }
}

.rotateInDownRight {
    -webkit-animation-name: rotateInDownRight;
    animation-name: rotateInDownRight;
}

@-webkit-keyframes rotateInUpLeft {
    from {
        -webkit-transform: rotate3d(0, 0, 1, 45deg);
        -webkit-transform-origin: left bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 45deg);
        transform-origin: left bottom;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: left bottom;
        opacity: 1;
        transform: none;
        transform-origin: left bottom;
    }
}

@keyframes rotateInUpLeft {
    from {
        -webkit-transform: rotate3d(0, 0, 1, 45deg);
        -webkit-transform-origin: left bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 45deg);
        transform-origin: left bottom;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: left bottom;
        opacity: 1;
        transform: none;
        transform-origin: left bottom;
    }
}

.rotateInUpLeft {
    -webkit-animation-name: rotateInUpLeft;
    animation-name: rotateInUpLeft;
}

@-webkit-keyframes rotateInUpRight {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -90deg);
        -webkit-transform-origin: right bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -90deg);
        transform-origin: right bottom;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: right bottom;
        opacity: 1;
        transform: none;
        transform-origin: right bottom;
    }
}

@keyframes rotateInUpRight {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -90deg);
        -webkit-transform-origin: right bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -90deg);
        transform-origin: right bottom;
    }

    to {
        -webkit-transform: none;
        -webkit-transform-origin: right bottom;
        opacity: 1;
        transform: none;
        transform-origin: right bottom;
    }
}

.rotateInUpRight {
    -webkit-animation-name: rotateInUpRight;
    animation-name: rotateInUpRight;
}

@-webkit-keyframes rotateOut {
    from {
        -webkit-transform-origin: center;
        opacity: 1;
        transform-origin: center;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, 200deg);
        -webkit-transform-origin: center;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 200deg);
        transform-origin: center;
    }
}

@keyframes rotateOut {
    from {
        -webkit-transform-origin: center;
        opacity: 1;
        transform-origin: center;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, 200deg);
        -webkit-transform-origin: center;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 200deg);
        transform-origin: center;
    }
}

.rotateOut {
    -webkit-animation-name: rotateOut;
    animation-name: rotateOut;
}

@-webkit-keyframes rotateOutDownLeft {
    from {
        -webkit-transform-origin: left bottom;
        opacity: 1;
        transform-origin: left bottom;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, 45deg);
        -webkit-transform-origin: left bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 45deg);
        transform-origin: left bottom;
    }
}

@keyframes rotateOutDownLeft {
    from {
        -webkit-transform-origin: left bottom;
        opacity: 1;
        transform-origin: left bottom;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, 45deg);
        -webkit-transform-origin: left bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 45deg);
        transform-origin: left bottom;
    }
}

.rotateOutDownLeft {
    -webkit-animation-name: rotateOutDownLeft;
    animation-name: rotateOutDownLeft;
}

@-webkit-keyframes rotateOutDownRight {
    from {
        -webkit-transform-origin: right bottom;
        opacity: 1;
        transform-origin: right bottom;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, -45deg);
        -webkit-transform-origin: right bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -45deg);
        transform-origin: right bottom;
    }
}

@keyframes rotateOutDownRight {
    from {
        -webkit-transform-origin: right bottom;
        opacity: 1;
        transform-origin: right bottom;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, -45deg);
        -webkit-transform-origin: right bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -45deg);
        transform-origin: right bottom;
    }
}

.rotateOutDownRight {
    -webkit-animation-name: rotateOutDownRight;
    animation-name: rotateOutDownRight;
}

@-webkit-keyframes rotateOutUpLeft {
    from {
        -webkit-transform-origin: left bottom;
        opacity: 1;
        transform-origin: left bottom;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, -45deg);
        -webkit-transform-origin: left bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -45deg);
        transform-origin: left bottom;
    }
}

@keyframes rotateOutUpLeft {
    from {
        -webkit-transform-origin: left bottom;
        opacity: 1;
        transform-origin: left bottom;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, -45deg);
        -webkit-transform-origin: left bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, -45deg);
        transform-origin: left bottom;
    }
}

.rotateOutUpLeft {
    -webkit-animation-name: rotateOutUpLeft;
    animation-name: rotateOutUpLeft;
}

@-webkit-keyframes rotateOutUpRight {
    from {
        -webkit-transform-origin: right bottom;
        opacity: 1;
        transform-origin: right bottom;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, 90deg);
        -webkit-transform-origin: right bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 90deg);
        transform-origin: right bottom;
    }
}

@keyframes rotateOutUpRight {
    from {
        -webkit-transform-origin: right bottom;
        opacity: 1;
        transform-origin: right bottom;
    }

    to {
        -webkit-transform: rotate3d(0, 0, 1, 90deg);
        -webkit-transform-origin: right bottom;
        opacity: 0;
        transform: rotate3d(0, 0, 1, 90deg);
        transform-origin: right bottom;
    }
}

.rotateOutUpRight {
    -webkit-animation-name: rotateOutUpRight;
    animation-name: rotateOutUpRight;
}

@-webkit-keyframes hinge {
    0% {
        -webkit-animation-timing-function: ease-in-out;
        -webkit-transform-origin: top left;
        animation-timing-function: ease-in-out;
        transform-origin: top left;
    }

    20%, 60% {
        -webkit-animation-timing-function: ease-in-out;
        -webkit-transform: rotate3d(0, 0, 1, 80deg);
        -webkit-transform-origin: top left;
        animation-timing-function: ease-in-out;
        transform: rotate3d(0, 0, 1, 80deg);
        transform-origin: top left;
    }

    40%, 80% {
        -webkit-animation-timing-function: ease-in-out;
        -webkit-transform: rotate3d(0, 0, 1, 60deg);
        -webkit-transform-origin: top left;
        animation-timing-function: ease-in-out;
        opacity: 1;
        transform: rotate3d(0, 0, 1, 60deg);
        transform-origin: top left;
    }

    to {
        -webkit-transform: translate3d(0, 700px, 0);
        opacity: 0;
        transform: translate3d(0, 700px, 0);
    }
}

@keyframes hinge {
    0% {
        -webkit-animation-timing-function: ease-in-out;
        -webkit-transform-origin: top left;
        animation-timing-function: ease-in-out;
        transform-origin: top left;
    }

    20%, 60% {
        -webkit-animation-timing-function: ease-in-out;
        -webkit-transform: rotate3d(0, 0, 1, 80deg);
        -webkit-transform-origin: top left;
        animation-timing-function: ease-in-out;
        transform: rotate3d(0, 0, 1, 80deg);
        transform-origin: top left;
    }

    40%, 80% {
        -webkit-animation-timing-function: ease-in-out;
        -webkit-transform: rotate3d(0, 0, 1, 60deg);
        -webkit-transform-origin: top left;
        animation-timing-function: ease-in-out;
        opacity: 1;
        transform: rotate3d(0, 0, 1, 60deg);
        transform-origin: top left;
    }

    to {
        -webkit-transform: translate3d(0, 700px, 0);
        opacity: 0;
        transform: translate3d(0, 700px, 0);
    }
}

.hinge {
    -webkit-animation-name: hinge;
    animation-name: hinge;
}

/* originally authored by Nick Pettit - https://github.com/nickpettit/glide */

@-webkit-keyframes rollIn {
    from {
        -webkit-transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
        opacity: 0;
        transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

@keyframes rollIn {
    from {
        -webkit-transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
        opacity: 0;
        transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
    }

    to {
        -webkit-transform: none;
        opacity: 1;
        transform: none;
    }
}

.rollIn {
    -webkit-animation-name: rollIn;
    animation-name: rollIn;
}

/* originally authored by Nick Pettit - https://github.com/nickpettit/glide */

@-webkit-keyframes rollOut {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
        opacity: 0;
        transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
    }
}

@keyframes rollOut {
    from { opacity: 1; }

    to {
        -webkit-transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
        opacity: 0;
        transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
    }
}

.rollOut {
    -webkit-animation-name: rollOut;
    animation-name: rollOut;
}

@-webkit-keyframes zoomIn {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        opacity: 0;
        transform: scale3d(.3, .3, .3);
    }

    50% { opacity: 1; }
}

@keyframes zoomIn {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        opacity: 0;
        transform: scale3d(.3, .3, .3);
    }

    50% { opacity: 1; }
}

.zoomIn {
    -webkit-animation-name: zoomIn;
    animation-name: zoomIn;
}

@-webkit-keyframes zoomInDown {
    from {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(0, -1000px, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(0, -1000px, 0);
    }

    60% {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
    }
}

@keyframes zoomInDown {
    from {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(0, -1000px, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(0, -1000px, 0);
    }

    60% {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
    }
}

.zoomInDown {
    -webkit-animation-name: zoomInDown;
    animation-name: zoomInDown;
}

@-webkit-keyframes zoomInLeft {
    from {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(-1000px, 0, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(-1000px, 0, 0);
    }

    60% {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(10px, 0, 0);
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(10px, 0, 0);
    }
}

@keyframes zoomInLeft {
    from {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(-1000px, 0, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(-1000px, 0, 0);
    }

    60% {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(10px, 0, 0);
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(10px, 0, 0);
    }
}

.zoomInLeft {
    -webkit-animation-name: zoomInLeft;
    animation-name: zoomInLeft;
}

@-webkit-keyframes zoomInRight {
    from {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(1000px, 0, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(1000px, 0, 0);
    }

    60% {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(-10px, 0, 0);
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(-10px, 0, 0);
    }
}

@keyframes zoomInRight {
    from {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(1000px, 0, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(1000px, 0, 0);
    }

    60% {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(-10px, 0, 0);
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(-10px, 0, 0);
    }
}

.zoomInRight {
    -webkit-animation-name: zoomInRight;
    animation-name: zoomInRight;
}

@-webkit-keyframes zoomInUp {
    from {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(0, 1000px, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(0, 1000px, 0);
    }

    60% {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
    }
}

@keyframes zoomInUp {
    from {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(0, 1000px, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(0, 1000px, 0);
    }

    60% {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
    }
}

.zoomInUp {
    -webkit-animation-name: zoomInUp;
    animation-name: zoomInUp;
}

@-webkit-keyframes zoomOut {
    from { opacity: 1; }

    50% {
        -webkit-transform: scale3d(.3, .3, .3);
        opacity: 0;
        transform: scale3d(.3, .3, .3);
    }

    to { opacity: 0; }
}

@keyframes zoomOut {
    from { opacity: 1; }

    50% {
        -webkit-transform: scale3d(.3, .3, .3);
        opacity: 0;
        transform: scale3d(.3, .3, .3);
    }

    to { opacity: 0; }
}

.zoomOut {
    -webkit-animation-name: zoomOut;
    animation-name: zoomOut;
}

@-webkit-keyframes zoomOutDown {
    40% {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
    }

    to {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(0, 2000px, 0);
        -webkit-transform-origin: center bottom;
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(0, 2000px, 0);
        transform-origin: center bottom;
    }
}

@keyframes zoomOutDown {
    40% {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
    }

    to {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(0, 2000px, 0);
        -webkit-transform-origin: center bottom;
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(0, 2000px, 0);
        transform-origin: center bottom;
    }
}

.zoomOutDown {
    -webkit-animation-name: zoomOutDown;
    animation-name: zoomOutDown;
}

@-webkit-keyframes zoomOutLeft {
    40% {
        -webkit-transform: scale3d(.475, .475, .475) translate3d(42px, 0, 0);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(42px, 0, 0);
    }

    to {
        -webkit-transform: scale(.1) translate3d(-2000px, 0, 0);
        -webkit-transform-origin: left center;
        opacity: 0;
        transform: scale(.1) translate3d(-2000px, 0, 0);
        transform-origin: left center;
    }
}

@keyframes zoomOutLeft {
    40% {
        -webkit-transform: scale3d(.475, .475, .475) translate3d(42px, 0, 0);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(42px, 0, 0);
    }

    to {
        -webkit-transform: scale(.1) translate3d(-2000px, 0, 0);
        -webkit-transform-origin: left center;
        opacity: 0;
        transform: scale(.1) translate3d(-2000px, 0, 0);
        transform-origin: left center;
    }
}

.zoomOutLeft {
    -webkit-animation-name: zoomOutLeft;
    animation-name: zoomOutLeft;
}

@-webkit-keyframes zoomOutRight {
    40% {
        -webkit-transform: scale3d(.475, .475, .475) translate3d(-42px, 0, 0);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(-42px, 0, 0);
    }

    to {
        -webkit-transform: scale(.1) translate3d(2000px, 0, 0);
        -webkit-transform-origin: right center;
        opacity: 0;
        transform: scale(.1) translate3d(2000px, 0, 0);
        transform-origin: right center;
    }
}

@keyframes zoomOutRight {
    40% {
        -webkit-transform: scale3d(.475, .475, .475) translate3d(-42px, 0, 0);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(-42px, 0, 0);
    }

    to {
        -webkit-transform: scale(.1) translate3d(2000px, 0, 0);
        -webkit-transform-origin: right center;
        opacity: 0;
        transform: scale(.1) translate3d(2000px, 0, 0);
        transform-origin: right center;
    }
}

.zoomOutRight {
    -webkit-animation-name: zoomOutRight;
    animation-name: zoomOutRight;
}

@-webkit-keyframes zoomOutUp {
    40% {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
    }

    to {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(0, -2000px, 0);
        -webkit-transform-origin: center bottom;
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(0, -2000px, 0);
        transform-origin: center bottom;
    }
}

@keyframes zoomOutUp {
    40% {
        -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        -webkit-transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
        animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        opacity: 1;
        transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
    }

    to {
        -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        -webkit-transform: scale3d(.1, .1, .1) translate3d(0, -2000px, 0);
        -webkit-transform-origin: center bottom;
        animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        opacity: 0;
        transform: scale3d(.1, .1, .1) translate3d(0, -2000px, 0);
        transform-origin: center bottom;
    }
}

.zoomOutUp {
    -webkit-animation-name: zoomOutUp;
    animation-name: zoomOutUp;
}

@-webkit-keyframes slideInDown {
    from {
        -webkit-transform: translate3d(0, -100%, 0);
        transform: translate3d(0, -100%, 0);
        visibility: visible;
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

@keyframes slideInDown {
    from {
        -webkit-transform: translate3d(0, -100%, 0);
        transform: translate3d(0, -100%, 0);
        visibility: visible;
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

.slideInDown {
    -webkit-animation-name: slideInDown;
    animation-name: slideInDown;
}

@-webkit-keyframes slideInLeft {
    from {
        -webkit-transform: translate3d(-100%, 0, 0);
        transform: translate3d(-100%, 0, 0);
        visibility: visible;
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

@keyframes slideInLeft {
    from {
        -webkit-transform: translate3d(-100%, 0, 0);
        transform: translate3d(-100%, 0, 0);
        visibility: visible;
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

.slideInLeft {
    -webkit-animation-name: slideInLeft;
    animation-name: slideInLeft;
}

@-webkit-keyframes slideInRight {
    from {
        -webkit-transform: translate3d(100%, 0, 0);
        transform: translate3d(100%, 0, 0);
        visibility: visible;
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

@keyframes slideInRight {
    from {
        -webkit-transform: translate3d(100%, 0, 0);
        transform: translate3d(100%, 0, 0);
        visibility: visible;
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

.slideInRight {
    -webkit-animation-name: slideInRight;
    animation-name: slideInRight;
}

@-webkit-keyframes slideInUp {
    from {
        -webkit-transform: translate3d(0, 100%, 0);
        transform: translate3d(0, 100%, 0);
        visibility: visible;
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

@keyframes slideInUp {
    from {
        -webkit-transform: translate3d(0, 100%, 0);
        transform: translate3d(0, 100%, 0);
        visibility: visible;
    }

    to {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }
}

.slideInUp {
    -webkit-animation-name: slideInUp;
    animation-name: slideInUp;
}

@-webkit-keyframes slideOutDown {
    from {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    to {
        -webkit-transform: translate3d(0, 100%, 0);
        transform: translate3d(0, 100%, 0);
        visibility: hidden;
    }
}

@keyframes slideOutDown {
    from {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    to {
        -webkit-transform: translate3d(0, 100%, 0);
        transform: translate3d(0, 100%, 0);
        visibility: hidden;
    }
}

.slideOutDown {
    -webkit-animation-name: slideOutDown;
    animation-name: slideOutDown;
}

@-webkit-keyframes slideOutLeft {
    from {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    to {
        -webkit-transform: translate3d(-100%, 0, 0);
        transform: translate3d(-100%, 0, 0);
        visibility: hidden;
    }
}

@keyframes slideOutLeft {
    from {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    to {
        -webkit-transform: translate3d(-100%, 0, 0);
        transform: translate3d(-100%, 0, 0);
        visibility: hidden;
    }
}

.slideOutLeft {
    -webkit-animation-name: slideOutLeft;
    animation-name: slideOutLeft;
}

@-webkit-keyframes slideOutRight {
    from {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    to {
        -webkit-transform: translate3d(100%, 0, 0);
        transform: translate3d(100%, 0, 0);
        visibility: hidden;
    }
}

@keyframes slideOutRight {
    from {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    to {
        -webkit-transform: translate3d(100%, 0, 0);
        transform: translate3d(100%, 0, 0);
        visibility: hidden;
    }
}

.slideOutRight {
    -webkit-animation-name: slideOutRight;
    animation-name: slideOutRight;
}

@-webkit-keyframes slideOutUp {
    from {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    to {
        -webkit-transform: translate3d(0, -100%, 0);
        transform: translate3d(0, -100%, 0);
        visibility: hidden;
    }
}

@keyframes slideOutUp {
    from {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

    to {
        -webkit-transform: translate3d(0, -100%, 0);
        transform: translate3d(0, -100%, 0);
        visibility: hidden;
    }
}

.slideOutUp {
    -webkit-animation-name: slideOutUp;
    animation-name: slideOutUp;
}
</file>

<file path="src/shared/Utils/Announce/Announce.module.scss">
.announce {
  animation-duration: 3s;
  animation-name: fadeOut;
}

@keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}
</file>

<file path="src/shared/Utils/BigTexts/aa.module.scss">
.container {
  display: flex;
  flex-direction: column;
  width: 100vw;
  height: 100vh;
}

.block {
  display: flex;
  width: 100vw;
  height: 25%;
}

.block_image {
  display: flex;
  width: 100vw;
  height: 50%;

  > img {
    width: 100%;
    height: 100%;
  }
}

.image {
  width: 100%;
  height: 100%;
}
</file>

<file path="src/shared/Utils/BigTexts/BigTextStyles.module.scss">
.grid {
  align-items: center;
  display: flex;
  flex-direction: column;
  min-height: 100%;
  justify-content: stretch;
  width: 100%;

  > div > div:first-child {
    background-color: black;
  }
}

.grid_cell {
  align-items: center;
  color: white;
  display: flex;
  font-family: fantasy;
  font-variant: all-petite-caps;
  font-weight: 500;
  height: calc(100vh / 5);
  width: 100%;
}
</file>

<file path="src/shared/Utils/FullText/FullText.tsx">
import { useEffect, useRef, useState } from "react";

interface Props {
  compressor?: number;
  minFontSize?: number;
  maxFontSize?: number;
  children: React.ReactNode;
}

export const FullText = ({
  compressor = 1,
  minFontSize = Number.NEGATIVE_INFINITY,
  maxFontSize = Number.POSITIVE_INFINITY,
  children,
}: Props) => {
  const elementRef = useRef<HTMLDivElement>(null);
  const [fontSize, setFontSize] = useState<number | undefined>();

  useEffect(() => {
    const resizer = () => {
      if (elementRef.current) {
        const width = elementRef.current.offsetWidth;
        const newFontSize = Math.max(
          Math.min(width / (compressor * 10), maxFontSize),
          minFontSize,
        );
        setFontSize(newFontSize);
      }
    };

    // Initial call to set the font size
    resizer();

    // Add event listeners for resize and orientation change
    window.addEventListener("resize", resizer);
    window.addEventListener("orientationchange", resizer);

    // Cleanup event listeners on component unmount
    return () => {
      window.removeEventListener("resize", resizer);
      window.removeEventListener("orientationchange", resizer);
    };
  }, [compressor, minFontSize, maxFontSize]);

  return (
    <div
      ref={elementRef}
      style={{ fontSize: fontSize ? `${fontSize}px` : undefined }}
    >
      {children}
    </div>
  );
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_BASE_PATH: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ESNext",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path=".gitignore">
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUNIT
*.VisualState.xml
TestResult.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# JustCode is a .NET coding add-in
.JustCode

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- Backup*.rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# JetBrains Rider
.idea/
*.sln.iml

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# BeatPulse healthcheck temp database
healthchecksdb
/TelegramService/TODO.txt
/TelegramService/appsettings.json
/Telegramus/wwwroot/TelegramCache/stickers
/Telegramus/wwwroot/Alerts
/Telegramus/wwwroot/Alerts/*
/Telegramus/wwwroot/Alerts/cringe.mp4

#DataBase
*.db*
/Telegramus/appsettings.json
/Telegramus/appsettings.Development.json
/Telegramus/appsettings.Production.json
/Telegramus/TGCache/*
/Telegramus/TGCache
/Telegramus/client_secrets.json
/Telegramus/client_secret_1_835410875823-80jgetlo7kd4rec9sdu7lb036ejggj9g.apps.googleusercontent.com.json
/Telegramus/TwitchToken.json
/Telegramus/TwitchCache
/Telegramus/Twichasd
/Telegramus/twitchasd


# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="eslint.config.js">
//*@ts-check*
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";
import { fixupConfigRules } from "@eslint/compat";
import eslintConfigPrettier from "eslint-config-prettier";
import prettier from "eslint-plugin-prettier"; // Import the Prettier plugin
import typescriptEslint from "@typescript-eslint/eslint-plugin";
import simpleImportSort from "eslint-plugin-simple-import-sort";
import typescriptParser from "@typescript-eslint/parser";
import react from "eslint-plugin-react";

export default tseslint.config(
  js.configs.recommended,
  tseslint.configs.recommended,
  {
    plugins: {
      prettier: prettier,
    },
    rules: {
      "prettier/prettier": [
        "warn",
        {
          endOfLine: "auto",
        },
      ],
    },
  },
  ...fixupConfigRules({
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: "latest",
      globals: globals.browser,
    },
    settings: {
      react: {
        version: "detect",
      },
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
      typescriptEslint,
      "simple-import-sort": simpleImportSort,
      react: react,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "unicode-bom": "error",
      "arrow-body-style": "error",
      "prefer-arrow-callback": "error",
      "react/jsx-uses-react": "off",
      "react/react-in-jsx-scope": "off",
      "simple-import-sort/imports": "error",
      "react/no-children-prop": "error",
      "no-restricted-imports": [
        "error",
        {
          paths: [
            {
              name: "react",
              importNames: ["default"],
              message: "Импортируйте конкретные объекты, а не весь React.",
            },
          ],
        },
      ],
      "react-refresh/only-export-components": [
        "error",
        { allowConstantExport: true, endOfLine: "auto" },
      ],
    },
    ignores: [
      "src/services/*",
      "dist/**",
      "node_modules/**",
      "**/*.md",
      "build/**",
      "vite.config.ts",
      "obj/**",
    ],
  }),
  {
    files: ["**/*.{js,ts,tsx}"],
    languageOptions: {
      parser: typescriptParser,
      parserOptions: {
        ecmaFeatures: {
          jsx: true,
        },
        ecmaVersion: 11,
        sourceType: "module",
      },
    },
  },
  eslintConfigPrettier,
);
</file>

<file path="run.bat">
@echo off
yarn vite preview --mode production --port 9159
</file>

<file path="src/components/ChatHorizontal/Message.module.css">
div {
  font-family: "Roboto", sans-serif;
  text-shadow:
    rgb(0, 0, 0) 2px 0px 0px,
    rgb(0, 0, 0) 1.75517px 0.958851px 0px,
    rgb(0, 0, 0) 1.0806px 1.68294px 0px,
    rgb(0, 0, 0) 0.141474px 1.99499px 0px,
    rgb(0, 0, 0) -0.832294px 1.81859px 0px,
    rgb(0, 0, 0) -1.60229px 1.19694px 0px,
    rgb(0, 0, 0) -1.97998px 0.28224px 0px,
    rgb(0, 0, 0) -1.87291px -0.701566px 0px,
    rgb(0, 0, 0) -1.30729px -1.5136px 0px,
    rgb(0, 0, 0) -0.421592px -1.95506px 0px,
    rgb(0, 0, 0) 0.567324px -1.91785px 0px,
    rgb(0, 0, 0) 1.41734px -1.41108px 0px,
    rgb(0, 0, 0) 1.92034px -0.558831px 0px;
}

.message {
  display: inline-flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  width: auto;
  visibility: hidden;
}

.message > div {
  margin-left: 5px;
}

.icons {
  display: inline;
}

.nickname {
  white-space: nowrap; /* Чтобы текст не переносился */
}

@keyframes slideInAndOut {
  from {
    transform: translateX(100vw);
  }
  to {
    transform: translateX(-100vw);
  }
}

.slideInAndOut {
  -webkit-animation-name: slideInAndOut;
  animation-name: slideInAndOut;
}

.text {
  white-space: nowrap;
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
  justify-content: center;
}

.text > span {
  color: rgb(51, 255, 0);
  text-decoration: none;
  text-decoration-color: rgb(38, 0, 255);
}

.text > img {
  max-height: 1.3em;
}
</file>

<file path="src/components/FumoFriday/Cirno.tsx">
import { useState } from "react";
import { Textfit } from "react-textfit";

import RainbowText from "../../shared/components/RainbowText/RainbowText";
import { Message } from "./FumoFridayController";
import styles from "./Styles.module.scss";

interface Props {
  displayName: Message;
  callback: () => void;
}

export function Cirno({ callback, displayName }: Props) {
  const [show, setShow] = useState<boolean>(true);

  return (
    <div className={styles["box-container"]}>
      <div
        style={{ visibility: show ? "visible" : "hidden" }}
        className={styles.container}
      >
        <Textfit className={styles.text} mode="single">
          <div>
            Поздравляю{" "}
            <span style={{ color: displayName.color }}>
              {displayName.message}!
            </span>
          </div>
          <div style={{ display: "inline-flex" }}>
            <RainbowText text="HAPPY FUMO FRIDAY!" />
          </div>
        </Textfit>
        <div>
          <video
            src={import.meta.env.VITE_BASE_PATH + "Alerts/Cirno.webm"}
            autoPlay
            controls={false}
            style={{ maxWidth: "100%" }}
            onEnded={() => {
              setShow(false);
              setTimeout(() => {
                callback();
              }, 1500);
            }}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FumoFriday/FumoFridayController.tsx">
import { useCallback, useState } from "react";
import { v4 as uuidv4 } from "uuid";

import { SignalRContext } from "../../app";
import { Cirno } from "./Cirno";
import { Reimu } from "./Reimu";

export interface Message {
  id: string;
  message: string;
  color?: string;
}

export function FumoFridayController() {
  const [_, setMessages] = useState<Message[]>([]);
  const [currentMessage, setCurrentMessage] = useState<Message | undefined>(
    undefined,
  );
  const [switcher, setSwitcher] = useState(false);

  SignalRContext.useSignalREffect(
    "fumofriday",
    (message, color) => {
      const id = uuidv4();
      const newMessage: Message = { id: id, message: message, color: color };
      handleAddEvent(newMessage);
    },
    [],
  );

  const handleAddEvent = useCallback(
    (message: Message) => {
      setMessages((prevMessages) => {
        if (!currentMessage) {
          setCurrentMessage(message);
          return prevMessages;
        }
        return [...prevMessages, message];
      });
    },
    [currentMessage],
  );

  const changeSwitcher = useCallback(() => {
    setSwitcher((prevSwitcher) => !prevSwitcher);
  }, []);

  const handleRemoveEvent = useCallback(
    (message: Message) => {
      setMessages((prevMessages) => {
        const newMessages = prevMessages.filter((msg) => msg.id !== message.id);
        setCurrentMessage(newMessages[0]);
        return newMessages;
      });
      changeSwitcher();
    },
    [changeSwitcher],
  );

  return (
    <>
      {currentMessage && switcher && (
        <Reimu
          key={currentMessage.id}
          callback={() => handleRemoveEvent(currentMessage)}
          displayName={currentMessage}
        />
      )}
      {currentMessage && !switcher && (
        <Cirno
          key={currentMessage.id}
          callback={() => handleRemoveEvent(currentMessage)}
          displayName={currentMessage}
        />
      )}
    </>
  );
}
</file>

<file path="src/components/FumoFriday/Reimu.tsx">
import { useState } from "react";
import { Textfit } from "react-textfit";

import RainbowText from "../../shared/components/RainbowText/RainbowText";
import { Message } from "./FumoFridayController";
import styles from "./Styles.module.scss";

interface Props {
  displayName: Message;
  callback: () => void;
}

export function Reimu({ callback, displayName }: Props) {
  const [show, setShow] = useState<boolean>(true);

  return (
    <div className={styles['box-container']}>
      <div
        className={styles.container}
        style={{ visibility: show ? "visible" : "hidden" }}
      >
        <div>
          <video
            src={import.meta.env.VITE_BASE_PATH + "Alerts/Reimu.webm"}
            autoPlay
            controls={false}
            style={{ maxWidth: "100%" }}
            onEnded={() => {
              setShow(false);
              setTimeout(() => {
                callback();
              }, 1500);
            }}
          />
        </div>
        <div className={styles.text}>
          <Textfit mode="single">
            <div>
              Поздравляю{" "}
              <span style={{ color: displayName.color }}>
                {displayName.message}
              </span>
              !
            </div>
            <div>
              <RainbowText text="HAPPY FUMO FRIDAY!" />
            </div>
          </Textfit>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FumoFriday/Styles.module.scss">
.box-container {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: space-around;
  min-height: 100vh;
  width: 100%;
  text-align: center;
  padding: 20px;
  align-self: center;
  color: white;
}

.container {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: space-around;
  min-height: 100%;
  width: 100%;
  text-align: center;
  padding: 20px;
  align-self: center;
  color: white;
}

.text {
  min-height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.fumo-words {
  color: red;
}
</file>

<file path="src/components/PyroAlerts/HighPriorityAlert.tsx">
import {
  MediaDto,
  MediaFileInfoTypeEnum,
} from "../../shared/api/generated/baza";
import { Audio, Image, Video, Voice } from "./Primitive";
import TelegramSticker from "./Primitive/TelegramSticker";

export interface AlertDestination {
  message: MediaDto;
  type: MediaFileInfoTypeEnum;
  callback: () => void;
}

export default function HighPriorityAlert(alert: AlertDestination) {
  const message = alert.message;
  const callback = alert.callback;

  switch (alert.type) {
    case MediaFileInfoTypeEnum.Image:
    case MediaFileInfoTypeEnum.Gif:
      return (
        <Image
          key={message.mediaInfo.id}
          mediaInfo={message}
          callBack={() => callback()}
        />
      );
    case MediaFileInfoTypeEnum.Video:
      return (
        <Video
          key={message.mediaInfo.id}
          MediaInfo={message}
          callback={() => callback()}
          isHighPrior
        />
      );
    case MediaFileInfoTypeEnum.Audio:
      return (
        <Audio
          key={message.mediaInfo.id}
          mediaInfo={message}
          callback={() => callback()}
          isHighPrior
        />
      );
    case MediaFileInfoTypeEnum.Voice:
      return (
        <Voice
          key={message.mediaInfo.id}
          mediaInfo={message}
          callback={() => callback()}
          isHighPrior
        />
      );
    case MediaFileInfoTypeEnum.TelegramSticker:
      return (
        <TelegramSticker
          key={message.mediaInfo.id}
          mediaInfo={message}
          callBack={() => callback()}
        />
      );
    default:
      return null;
  }
}
</file>

<file path="src/components/PyroAlerts/Primitive/Media.module.scss">
.media {
  display: flex;
  flex-direction: column;
  color: white;
  max-height: 100%;
  max-width: 100%;
  position: absolute;
}

.imageContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  position: absolute;
}

.key_word {
  color: red;
}

.container {
  display: flex;
  flex-direction: column;
  width: 100vw;
  height: 100vh;
}

.block {
  display: flex;
  width: 100vw;
  height: 25%;
  color: white;
  background-color: black;
  text-wrap: nowrap;
  text-align: center;
  align-items: center;

  > div {
    width: 100vw;
    height: 100%;
    align-content: center;

    > div > img {
      height: 1em;
      vertical-align: sub;
    }
  }
}

.block_image {
  display: flex;
  width: 100vw;
  height: 50%;

  > img {
    overflow: hidden;
    width: 100%;
    height: 100%;
  }
}

.image {
  width: 100%;
  height: 100%;
}
</file>

<file path="src/components/RandomMem/RandomMem.tsx">
import { useCallback, useEffect, useState } from "react";
import { SignalRContext } from "../../app";
import Announce from "../../shared/Utils/Announce/Announce";
import {
  MediaDto,
  MediaMetaInfoPriorityEnum,
} from "../../shared/api/generated/baza";
import { v4 as uuidv4 } from "uuid";
import HighPriorityAlert from "../PyroAlerts/HighPriorityAlert";
import Alert from "../PyroAlerts/Alert";

export default function PyroAlerts() {
  const [messages, setMessages] = useState<MediaDto[]>([]);
  const [highPriorityQueue, setHighPriorityQueue] = useState<MediaDto[]>([]);
  const [currentHighPriority, setCurrentHighPriority] =
    useState<MediaDto | null>(null);
  const [announced, setAnnounced] = useState(false);

  const handleAlert = useCallback((message: MediaDto) => {
    message.mediaInfo.id = uuidv4();

    switch (message.mediaInfo.metaInfo.priority) {
      case MediaMetaInfoPriorityEnum.High:
        const parsedMessage: MediaDto = {
          ...message,
          mediaInfo: {
            ...message.mediaInfo,
            fileInfo: {
              ...message.mediaInfo.fileInfo,
              filePath: message.mediaInfo.fileInfo.isLocalFile
                ? import.meta.env.VITE_BASE_PATH +
                  message.mediaInfo.fileInfo.filePath
                : message.mediaInfo.fileInfo.filePath,
            },
          },
        };

        setHighPriorityQueue((prev) => [...prev, parsedMessage]); // Добавляем в очередь высокоприоритетных
        setMessages([]);
        break;
      case MediaMetaInfoPriorityEnum.Low:
      case MediaMetaInfoPriorityEnum.Normal:
        const coolMessage: MediaDto = {
          ...message,
          mediaInfo: {
            ...message.mediaInfo,
            fileInfo: {
              ...message.mediaInfo.fileInfo,
              filePath: message.mediaInfo.fileInfo.isLocalFile
                ? import.meta.env.VITE_BASE_PATH +
                  message.mediaInfo.fileInfo.filePath
                : message.mediaInfo.fileInfo.filePath,
            },
          },
        };

        setMessages((prev) => [...prev, coolMessage]);
        break;
    }
  }, []);

  const remove = useCallback((message: MediaDto) => {
    setMessages((prev) =>
      prev.filter((m) => m.mediaInfo.id !== message.mediaInfo.id),
    );
  }, []);

  const removeHighPrior = useCallback((message: MediaDto) => {
    setHighPriorityQueue((prev) =>
      prev.filter((m) => m.mediaInfo.id !== message.mediaInfo.id),
    );

    const newPriority = highPriorityQueue.some((e) => e)
      ? highPriorityQueue[0]
      : null;
    setCurrentHighPriority(newPriority);
  }, []);

  // Эффект для обработки очереди высокоприоритетных алертов
  useEffect(() => {
    if (highPriorityQueue.length > 0 && !currentHighPriority) {
      // Берем первый алерт из очереди
      const nextAlert = highPriorityQueue[0];
      setCurrentHighPriority(nextAlert);

      // Удаляем его из очереди через 2 секунды (время показа)
      const timer = setTimeout(() => {
        setHighPriorityQueue((prev) => prev.slice(1));
        setCurrentHighPriority(null);
      }, 2000);

      return () => clearTimeout(timer);
    }
  }, [highPriorityQueue, currentHighPriority]);

  // Подписки на SignalR события
  SignalRContext.useSignalREffect("RandomMem", handleAlert, [handleAlert]);

  return (
    <>
      {!announced && (
        <Announce title={"RandomMem"} callback={() => setAnnounced(true)} />
      )}

      {/* Рендерим текущий высокоприоритетный алерт */}
      {currentHighPriority && (
        <HighPriorityAlert
          key={currentHighPriority.mediaInfo.id}
          message={currentHighPriority}
          type={currentHighPriority.mediaInfo.fileInfo.type}
          callback={() => removeHighPrior(currentHighPriority)}
        />
      )}

      {/* Рендерим обычные алерты, если нет высокоприоритетных */}
      {!currentHighPriority &&
        messages.map((messageProps) => (
          <Alert
            key={messageProps.mediaInfo.id}
            message={messageProps}
            remove={remove}
          />
        ))}
    </>
  );
}
</file>

<file path="src/components/ScreenParticles/Confetty.tsx">
import Fireworks from "react-canvas-confetti/dist/presets/fireworks";
import SchoolPride from "react-canvas-confetti/dist/presets/pride";

import { randomInRange } from ".";
import { useEffect } from "react";
const defaultOptions: confetti.Options = {
  spread: randomInRange(50, 70),
  particleCount: randomInRange(50, 100),
};

const variants: confetti.Options[] = [
  // Top
  {
    ...defaultOptions,
    angle: 315,
    origin: { y: 0, x: 0 },
  },
  {
    ...defaultOptions,
    angle: 270,
    origin: { y: 0, x: 0.5 },
  },
  {
    ...defaultOptions,
    angle: 235,
    origin: { y: 0, x: 0.5 },
  },
  // Middle
  {
    ...defaultOptions,
    angle: 0,
    origin: { y: 0.5, x: 0 },
  },
  {
    ...defaultOptions,
    startVelocity: 30,
    spread: 360,
    zIndex: 0,
    origin: { y: 0.5, x: 0.5 },
  },
  {
    ...defaultOptions,
    angle: 180,
    origin: { y: 0.5, x: 1 },
  },
  // Bottom
  {
    ...defaultOptions,
    angle: 45,
    origin: { y: 1, x: 0 },
  },
  {
    ...defaultOptions,
    angle: 90,
    origin: { y: 1, x: 0.5 },
  },
  {
    ...defaultOptions,
    angle: 135,
    origin: { y: 1, x: 1 },
  },
];

interface Props {
  callback: () => void;
}

export function Confettyv1({} : Props) {
  const randomVariant = variants[Math.floor(Math.random() * variants.length)];

  return (
    <Fireworks
      width="100%"
      height="100%"
      autorun={{ speed: 3, duration: 5000, delay: 5 }}
      decorateOptions={() => randomVariant}
    ></Fireworks>
  );
}

export function Confettyv2({ callback }: Props) {
  const duration = 10000;

  useEffect(() => {
    setTimeout(() => callback(), duration);
  }, [callback]);

  return (
    <>
      <SchoolPride
        width="100%"
        height="100%"
        autorun={{ speed: 30, duration }}
        decorateOptions={(): confetti.Options => {
          return {
            particleCount: 2,
            angle: 60,
            spread: 55,
            origin: { x: 0 },
            colors: ["#000000", "#FF0000", "#FFFFFF"],
          };
        }}
      />
      <SchoolPride
        width="100%"
        height="100%"
        autorun={{ speed: 30, duration }}
        decorateOptions={(): confetti.Options => {
          return {
            particleCount: 2,
            angle: 120,
            spread: 55,
            origin: { x: 1 },
            colors: ["#000000", "#FF0000", "#FFFFFF"],
          };
        }}
      />
    </>
  );
}
</file>

<file path="src/components/ScreenParticles/Firework.tsx">
import { useEffect } from "react";
import Fireworks from "react-canvas-confetti/dist/presets/fireworks";

interface Props {
  callback: () => void;
}

export default function Firework({ callback }: Props) {
  const duration = 10000;

  useEffect(() => {
    setTimeout(() => callback(), duration);
  }, [callback]);

  return (
    <Fireworks width="100%" height="100%" autorun={{ speed: 3, duration }} />
  );
}
</file>

<file path="src/components/SoundRequest/CurrentTrack/CurrentTrackManager.tsx">
import { useCallback, useState, useMemo, useEffect } from "react";
import { SignalRContext } from ".";
import {
  TunaMusicData,
  TunaMusicDTO,
} from "../../../shared/api/generated/baza";
import CurrentTrack from "./CurrentTrack";

const defaultValue: TunaMusicData & { isDefaultValue: boolean } = {
  album_url: "",
  artists: [],
  cover: "",
  duration: 0,
  progress: 0,
  status: "",
  title: "Not Playing",
  isDefaultValue: true,
};

interface TrackInfo {
  track: TunaMusicData & { isDefaultValue: boolean };
  count: number;
  shouldAnimate: boolean;
}

export default function CurrentTrackManager() {
  const [counter, setCounter] = useState(0);
  const [track, setTrack] = useState<TrackInfo>({
    track: defaultValue,
    count: counter,
    shouldAnimate: false,
  });

  const changeTrack = useCallback(
    (data: TunaMusicData) => {
      // Сначала запускаем анимацию
      setCounter((prev) => prev + 1);
      setTrack({
        track: { ...data, isDefaultValue: false },
        count: counter,
        shouldAnimate: true,
      });

      // Через время анимации меняем трек
      setTimeout(() => {
        setTrack((prev) => ({
          ...prev,
          shouldAnimate: false,
        }));
      }, 3500); // Общее время анимации (слайды + NOW PLAYING + финальная анимация)
    },
    [counter],
  );

  const trackKey = useMemo(
    () =>
      `${track.track.artists.join(", ")}-${track.track.title}-${track.count}`,
    [track.track.artists, track.track.title, track.count],
  );

  SignalRContext.useSignalREffect(
    "TunaMusicInfo",
    (data: TunaMusicDTO) => {
      // Проверяем, изменился ли трек
      const isNewTrack =
        data.data.artists.join(", ") !== track.track.artists.join(", ") ||
        data.data.title !== track.track.title;

      if (isNewTrack) {
        changeTrack(data.data);
        return;
      }

      // Если трек тот же, просто обновляем данные без анимации
      setTrack((prev) => ({
        ...prev,
        track: { ...data.data, isDefaultValue: false },
      }));
    },
    [track.track.artists, track.track.title, changeTrack],
  );

  useEffect(() => {
    console.log(counter);
  }, [counter]);

  return (
    !track.track.isDefaultValue && track.track.status !== "stopped" && (
      <CurrentTrack
        track={track.track}
        key={trackKey}
        shouldAnimate={track.shouldAnimate}
      />
    )
  );
}
</file>

<file path="src/components/SoundRequest/CurrentTrack/SignalRHubWrapper.tsx">
import { logger } from "../../../app/main";
import { SignalRContext } from ".";
import CurrentTrackManager from "./CurrentTrackManager";

export default function CurrentTrackSignalRHubWrapper() {
  return (
    <SignalRContext.Provider
      automaticReconnect={true}
      onError={(error) => new Promise((resolve) => resolve(console.log(error)))}
      onClosed={(event) => console.log(event)}
      onOpen={(event) => console.log(event)}
      logger={logger}
      withCredentials={false}
      url={import.meta.env.VITE_BASE_PATH + "tuna"}
      logMessageContent
    >
      <CurrentTrackManager />
    </SignalRContext.Provider>
  );
}
</file>

<file path="src/components/WaifuAlerts/helper.ts">
import { Waifu } from "../../shared/api/generated/baza";

export function shuffleArray<T>(array: T[]): T[] {
  // Копируем исходный массив, чтобы не изменять его
  const shuffledArray = [...array];

  // Перемешиваем массив
  for (let i = shuffledArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
  }

  return shuffledArray;
}

export function getText(message: WaifuAlertProps) {
  let text: string;
  if (message.waifu.isAdded) {
    text = "ты добавил";
  } else if (message.waifu.isMerged) {
    text = "поженился с";
  } else {
    text = "тебе выпал(-а)";
  }

  return text + " " + message.waifu.name;
}

export function getTitle(message: WaifuAlertProps) {
  if (message.waifu.anime) {
    return `из аниме ${message.waifu.anime}`;
  } else {
    return `из манги ${message.waifu.manga}`;
  }
}

export interface WaifuAlertProps {
  waifu: Waifu;
  displayName: string;
  color?: string;
  avatarUrl?: string;
}
</file>

<file path="src/components/WaifuAlerts/WaifuAlerts.module.scss">
html,
body {
  height: 100%;
  margin: 0;
}

div#root {
  min-height: 100%;
  flex-direction: column;
}

.baza {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  height: 100%;
  align-self: center;
}

.alert-box {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 48px;
  text-align: center;
}

.roulette-name-text {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 48px;
  text-align: center;
  text-transform: uppercase;
  color: white;
}

.smooth-box {
  overflow: hidden;
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  mask-image: linear-gradient(
    to right,
    rgba(0, 0, 0, 0) 0%,
    rgba(0, 0, 0, 1) 35%,
    rgba(0, 0, 0, 1) 75%,
    rgba(0, 0, 0, 0) 100%
  );
  pointer-events: none;
}

.merge-container {
  width: 100vw;
  height: 100vh;
  display: inline-flex;
  flex-direction: row;
  align-items: center;
  align-content: center;
  justify-items: center;
  flex-wrap: nowrap;
  background: radial-gradient(
    ellipse at center,
    rgba(245, 224, 220, 0.7) 0%,
    /* Бежевый цвет с прозрачностью 70% */ rgba(245, 245, 220, 0) 70%
      /* Полная прозрачность у краёв */
  );
  border-radius: 50%; /* Делает контейнер овальным */
  padding: 20px; /* Отступы внутри контейнера */
  box-sizing: border-box; /* Чтобы padding не влиял на общие размеры */

  .merge-text {
    display: flex;
    width: 100%;
    height: 100%;

    > div {
      width: 100%;
      height: 100%;
      align-content: center;

      > div {
        text-align: center;
        vertical-align: middle;
      }
    }
  }

  .merge-image {
    width: 100%;
    height: 100%;
    object-fit: fill;
    align-content: center;
    justify-content: center;

    > img {
      width: 100%;
      max-height: 100%;
      justify-self: center;
      object-fit: fill;
    }

    &:first-child > img {
      width: 100%;
      max-height: 100%;
      justify-self: center;
      object-fit: fill;

      &:first-child {
        float: right;
      }
    }
  }
}
</file>

<file path="src/shared/components/KeyWordText/KeyWordedText.tsx">
import { getRandomColor } from "../../Utils";

interface Props {
  keyWordedString: string;
  keySymbol: string;
  classNameForKeyWordedSpan: string;
  isQuouted?: boolean;
  keyWordColor?: string;
}

export function KeyWordedText({
  keySymbol = "#",
  keyWordedString,
  classNameForKeyWordedSpan = "key_word",
  keyWordColor = getRandomColor(),
  isQuouted,
}: Props) {
  if (keySymbol.length !== 1) {
    return undefined;
  }

  if (!keyWordedString) {
    return undefined;
  }

  const regex: RegExp = isQuouted
    ? new RegExp(`(${keySymbol}.*?${keySymbol})`, "g")
    : new RegExp(`(${keySymbol}\\S+)`, "g");

  const parts = keyWordedString.split(regex);

  return (
    <div>
      {parts.map((part, index) => {
        if (part.startsWith(keySymbol) && part.endsWith(keySymbol)) {
          const content = part.slice(1, -1);
          return (
            <span
              key={index}
              style={{ color: keyWordColor }}
              className={classNameForKeyWordedSpan}
            >
              {content}
            </span>
          );
        }
        return <span key={index}>{part}</span>;
      })}
    </div>
  );
}
</file>

<file path="src/shared/MIME_types.ts">
export const MIME_Types: Record<string, string> = {
  mp4: "video/mp4",
  m4v: "video/mp4",
  mov: "video/quicktime",
  qt: "video/quicktime",
  webm: "video/webm",
  ogv: "video/ogg",
  ogg: "video/ogg",
  avi: "video/x-msvideo",
  wmv: "video/x-ms-wmv",
  flv: "video/x-flv",
  mkv: "video/x-matroska",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  mpeg: "video/mpeg",
  mpg: "video/mpeg",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  png: "image/png",
  gif: "image/gif",
  webp: "image/webp",
  svg: "image/svg+xml",
  svgz: "image/svg+xml",
  bmp: "image/bmp",
  ico: "image/x-icon",
  tif: "image/tiff",
  tiff: "image/tiff",
  avif: "image/avif",
  apng: "image/apng",
  jfif: "image/jpeg",
  pjpeg: "image/jpeg",
  pjp: "image/jpeg",
};

/**
 * Добавляет атрибут type с MIME-типом для всех тегов img в HTML-строке
 * @param htmlText Входной HTML-текст
 * @returns Обработанный HTML-текст с добавленными атрибутами type
 */
export function addMimeTypesToImgTags(htmlText: string): string {
  // Регулярное выражение для поиска тегов img
  const imgTagRegex = /<img\s+([^>]*?)src=["']([^"']+)["']([^>]*?)>/gi;

  return htmlText.replace(imgTagRegex, (match, beforeSrc, src, afterSrc) => {
    // Извлекаем расширение файла из URL
    const extension =
      src.split(".").pop()?.toLowerCase().split(/[#?]/)[0] || "";

    debugger;
    // Получаем MIME-тип из нашей коллекции
    const mimeType = MIME_Types[extension] || "application/octet-stream";

    // Проверяем, есть ли уже атрибут type
    const hasTypeAttr = /type=["'][^"']*["']/i.test(match);

    // Если атрибут type уже есть, не изменяем его
    if (hasTypeAttr) {
      return match;
    }

    // Добавляем атрибут type
    return `<img ${beforeSrc}src="${src}" type="${mimeType}"${afterSrc}>`;
  });
}
</file>

<file path="src/shared/Utils/Announce/Announce.tsx">
import "./Announce.module.scss";

import { CSSProperties, useEffect, useRef, useState } from "react";
import { Textfit } from "react-textfit";

interface Props {
  title: string;
  callback: () => void;
}

const getRandomColor = (): string => {
  const letters = "0123456789ABCDEF";
  let color = "#";
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
};

export default function Announce({ title, callback }: Props) {
  document.title = title;
  const nodeRef = useRef(null);

  const backgroundColor = getRandomColor();

  const defaultStyle: CSSProperties = {
    position: "absolute" /* Абсолютное позиционирование */,
    top: "50%" /* Центрирование по вертикали */,
    left: "50%" /* Центрирование по горизонтали */,
    transform:
      "translate(-50%, -50%)" /* Сдвиг на половину ширины и высоты элемента для центрирования */,
    display: "flex",
    flexDirection: "column" /* Размещение элементов в колонку */,
    justifyContent: "center" /* Центрирование содержимого по вертикали */,
    alignItems: "center" /* Центрирование содержимого по горизонтали */,
    height: "30%" /* Высота блока будет зависеть от содержимого */,
    width: "80%" /* Ширина блока будет 80% от ширины экрана */,
    padding: "20px" /* Добавление отступов внутри блока */,
    backgroundColor: backgroundColor,
  };

  interface FadeOutProps {
    duration: number;
    delay: number;
    children: React.ReactNode;
    callback: () => void;
  }

  const FadeOut: React.FC<FadeOutProps> = ({
    duration,
    delay,
    children,
    callback,
  }) => {
    const elementRef = useRef<HTMLDivElement>(null);
    const [isVisible, setIsVisible] = useState(true);

    useEffect(() => {
      const element = elementRef.current;
      if (element) {
        const delayTimer = setTimeout(() => {
          if (element) {
            element.style.transition = `opacity ${duration}ms`;
            element.style.opacity = "0";

            const fadeOutTimer = setTimeout(() => {
              setIsVisible(false);
              callback();
            }, duration);

            return () => {
              clearTimeout(fadeOutTimer);
            };
          }
        }, delay);

        return () => {
          clearTimeout(delayTimer);
        };
      }
    }, [duration, delay, callback]);

    return isVisible ? <div ref={elementRef}>{children}</div> : null;
  };

  return (
    <FadeOut duration={2000} delay={3000} callback={callback}>
      <div ref={nodeRef} style={defaultStyle} className="announce">
        <Textfit
          id="announce"
          forceSingleModeWidth
          min={1}
          max={1500}
          style={{
            width: "100%",
            height: "100%",
            alignItems: "center",
            display: "flex",
            justifySelf: "center",
            alignSelf: "center",
            justifyContent: "center",
          }}
        >
          {title}
        </Textfit>
      </div>
    </FadeOut>
  );
}
</file>

<file path="src/shared/Utils/BigTexts/BigTextBlockForVoice.tsx">
import { Container, Row } from "react-bootstrap";
import { Textfit } from "react-textfit";

import styles from "./aa.module.scss";
import { MediaDto } from "../../api/generated/baza";
import { useCallback, useState } from "react";

interface Props {
  mediaInfo: MediaDto;
  callback: () => void;
}

export function BigTextBlockForVoice({ mediaInfo, callback }: Props) {
  const { metaInfo, fileInfo, textInfo } = mediaInfo.mediaInfo;
  const bellSrc = import.meta.env.VITE_BASE_PATH + "Alerts/bell.wav";
  const voiceSrc = import.meta.env.VITE_BASE_PATH + fileInfo.filePath;

  const [isBellPlayed, setIsBellPlayed] = useState(false);

  const error = useCallback(() => {
    throw Error("Failed to play audio");
    callback();
  }, [callback]);

  return (
    <>
      {!isBellPlayed && (
        <audio
          src={bellSrc}
          onEnded={() => setIsBellPlayed(true)}
          onError={() => error()}
          onErrorCapture={() => error()}
        />
      )}
      {isBellPlayed && (
        <audio
          src={voiceSrc}
          onEnded={() => callback()}
          onError={() => error()}
          onErrorCapture={() => error()}
        />
      )}
      {
        <Container className={styles.container}>
          <Row className={styles.block}>
            <Textfit
              forceSingleModeWidth
              style={{
                width: "100%",
                height: "100%",
                marginLeft: "auto",
                marginRight: "auto",
                textAlign: "center",
                alignContent: "center",
                alignItems: "center",
                display: "flex",
                justifyContent: "center",
              }}
              max={2000}
            >
              Стример, заткнись
            </Textfit>
          </Row>
          <Row className={styles.block_image}>
            <img src={import.meta.env.VITE_BASE_PATH + "Alerts/mute.png"} />
          </Row>
          <Row className={styles.block}>
            <Textfit
              forceSingleModeWidth
              style={{
                width: "100%",
                height: "100%",
                marginLeft: "auto",
                marginRight: "auto",
                textAlign: "center",
                alignContent: "center",
                alignItems: "center",
                display: "flex",
                justifyContent: "center",
              }}
            >
              Сейчас говорит <img className="emote" src={textInfo.text} />
              {metaInfo.displayName}
            </Textfit>
          </Row>
        </Container>
      }
    </>
  );
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable", "ESNext"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./src/assets/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PYRO REACT</title>
  </head>
  <body style="overflow: hidden">
    <div id="root"></div>
    <script type="module" src="/src/app/main.tsx"></script>
  </body>
</html>
</file>

<file path="src/components/HighliteMessage/Message.module.scss">
/* General CSS Setup */

:root {
  --color: #ff0000 #ff0000 transparent transparent;
  --calculated-height: calc(100vh / 29);
  --span-width: 100ch;
}

/* IMAGE */

.buble-image {
  position: absolute;
  right: 0%;
  bottom: -1%;
  margin: 0;

  > img {
    max-width: 250px;
    max-height: 250px;
    width: 250px;
    height: 250px;
    object-fit: fill;
    margin: 0;
  }

  > video {
    max-width: 250px;
    max-height: 250px;
    width: 250px;
    height: 250px;
    object-fit: fill;
    margin: 0;
  }
}

/* TEXT BOX */

.badge {
  height: var(--calculated-height);
  margin-right: 1%;
  max-height: var(--calculated-height);
  max-width: var(--calculated-height);
  width: var(--calculated-height);
}

.icons {
  align-items: center;
  display: flex;
  flex-direction: column;
  margin-right: 5px;
  overflow: visible;
  white-space: nowrap;
  height: 100%;
  width: 100%;
  gap: 12%;

  > div {
    height: 100%;
    width: 100%;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    align-content: center;
    align-items: center;
    justify-content: center;

    &:first-child {
      align-content: flex-end;
    }

    &:last-child {
      align-content: flex-start;
      justify-content: space-around;
    }

  }
}

.name {
  margin-right: 1vh;
  margin-left: 1vh;
  width: 100%;
  align-content: center;
  justify-items: center;

  & img {
    height: 1em;
  }
}

.emote {
  margin-left: 3px;
  margin-right: 3px;
  height: 2.7vh;
}

.emotes {
  white-space: pre-wrap;
  overflow: visible;
  width: 100%;
  font-family: "Ubuntu-Italic", "Lucida Sans", helvetica, sans;
  line-height: normal;
  height: 300px;
  text-align: center;
  align-items: center;
  justify-content: center;
  display: flex;
  word-break: keep-all;

  > div {
    // width: 100%;
    // height: 100%;
    vertical-align: sub;
    align-content: center;
  }
}

/* CSS talk bubble */
.talk-bubble {
  margin: 40px;
  display: inline-block;
  position: absolute;
  bottom: 30vh;
  right: 8vh;
  width: min-content;
  height: auto;
  text-wrap: balance;
  background-color: lightyellow;

  .talktext {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
    padding: 1rem;
  }
}

.round {
  border-radius: 30px;
}

/* talk bubble contents */
.talktext {
  text-align: left;
  line-height: 1.5em;
  display: inline-flex;
  flex-direction: row;
  align-items: center;
  width: 100%;
  height: 100%;
}

.bubble {
  --r: 1em; /* the radius */
  --t: 1.5em; /* the size of the tail */

  // max-width: 650px;
  padding: 1em;
  border-inline: var(--t) solid #0000;
  border-radius: calc(var(--r) + var(--t)) / var(--r);
  mask:
    radial-gradient(100% 100% at var(--_p) 0, #0000 99%, #000 102%) var(--_p)
      100% / var(--t) var(--t) no-repeat,
    linear-gradient(#000 0 0) padding-box;
  color: #fff;
  bottom: 180px;
  right: 300px;
  position: absolute;
  height: 30%;
  width: 40%;
}

.right {
  --_p: 100%;
  border-bottom-right-radius: 0 0;
  place-self: end;
}
</file>

<file path="src/components/SoundRequest/CurrentTrack/Animations/AnimationControl.tsx">
import { useCallback, useEffect, useState } from "react";
import { motion, AnimatePresence, Variant } from "framer-motion";
import styles from "../CurrentTrack.module.scss";
import AnimatedGradientBackground from "./AnimatedGradientBackground";

interface Props {
  children: React.ReactNode;
  AnimationStart: boolean;
}

type AnimationStage =
  | "idle"
  | "slidesCover"
  | "slidesReveal"
  | "nowPlaying"
  | "slidesCoverFinal"
  | "slidesRevealFinal"
  | "showChildren";

export default function AnimationControl({ children, AnimationStart }: Props) {
  const [animationStage, setAnimationStage] = useState<AnimationStage>("idle");
  const [nowPlayingCount, setNowPlayingCount] = useState(0);

  const startAnimation = useCallback(() => {
    if (!AnimationStart || animationStage !== "idle") return;

    setAnimationStage("slidesCover");
    setNowPlayingCount(0);
  }, [AnimationStart, animationStage]);

  useEffect(() => {
    if (AnimationStart) {
      startAnimation();
    }
  }, [AnimationStart, startAnimation]);

  const handleAnimationComplete = (stage: AnimationStage) => {
    switch (stage) {
      case "slidesCover":
        setTimeout(() => setAnimationStage("slidesReveal"), 300);
        break;
      case "slidesReveal":
        setTimeout(() => setAnimationStage("nowPlaying"), 200);
        break;
      case "nowPlaying":
        if (nowPlayingCount < 2) {
          setTimeout(() => {
            setNowPlayingCount((prev) => prev + 1);
          }, 800);
        } else {
          setTimeout(() => setAnimationStage("slidesCoverFinal"), 200);
        }
        break;
      case "slidesCoverFinal":
        setTimeout(() => setAnimationStage("slidesRevealFinal"), 300);
        break;
      case "slidesRevealFinal":
        setTimeout(() => setAnimationStage("showChildren"), 200);
        break;
      case "showChildren":
        setTimeout(() => setAnimationStage("idle"), 500);
        break;
    }
  };

  // Варианты анимации для слайдов
  const slideVariants: { [key: string]: { [key: string]: Variant } } = {
    top: {
      cover: { y: "0%" },
      reveal: { y: "-100%" },
      idle: { y: "-100%" },
    },
    bottom: {
      cover: { y: "0%" },
      reveal: { y: "100%" },
      idle: { y: "100%" },
    },
  };

  // Варианты для NOW PLAYING текста
  const nowPlayingVariants: { [key: string]: Variant } = {
    hidden: {
      y: -1000, // Начальная позиция выше экрана
      opacity: 0,
    },
    visible: {
      y: 0, // Конечная позиция по центру
      opacity: 1,
      transition: {
        type: "spring",
        damping: 20,
        stiffness: 300,
      },
    },
    exit: {
      y: 200, // Уезжает вниз
      opacity: 0,
      transition: {
        duration: 0.5,
        ease: "easeIn",
      },
    },
  };

  // Варианты для children
  const childrenVariants = {
    hidden: {
      scale: 0,
      opacity: 0,
    },
    visible: {
      scale: 1,
      opacity: 1,
      transition: {
        type: "spring" as const,
        damping: 15,
        stiffness: 200,
        delay: 0.2,
      },
    },
  };

  return (
    <AnimatedGradientBackground
    >
      {/* Верхний слайд */}
      <motion.div
        className={styles.slide}
        style={{
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          height: "50%",
          zIndex: 10,
        }}
        variants={slideVariants.top}
        animate={
          animationStage === "slidesCover" ||
          animationStage === "slidesCoverFinal"
            ? "cover"
            : animationStage === "slidesReveal" ||
                animationStage === "slidesRevealFinal"
              ? "reveal"
              : "idle"
        }
        transition={{
          duration: 0.6,
          ease: [0.25, 0.46, 0.45, 0.94],
        }}
        onAnimationComplete={() => {
          if (animationStage === "slidesCover")
            handleAnimationComplete("slidesCover");
          if (animationStage === "slidesReveal")
            handleAnimationComplete("slidesReveal");
          if (animationStage === "slidesCoverFinal")
            handleAnimationComplete("slidesCoverFinal");
          if (animationStage === "slidesRevealFinal")
            handleAnimationComplete("slidesRevealFinal");
        }}
      />

      {/* Нижний слайд */}
      <motion.div
        className={styles.slide}
        style={{
          position: "absolute",
          bottom: 0,
          left: 0,
          right: 0,
          height: "50%",
          zIndex: 10,
        }}
        variants={slideVariants.bottom}
        animate={
          animationStage === "slidesCover" ||
          animationStage === "slidesCoverFinal"
            ? "cover"
            : animationStage === "slidesReveal" ||
                animationStage === "slidesRevealFinal"
              ? "reveal"
              : "idle"
        }
        transition={{
          duration: 0.6,
          ease: [0.25, 0.46, 0.45, 0.94],
        }}
      />

      {/* NOW PLAYING текст */}
      <AnimatePresence mode="wait">
        {animationStage === "nowPlaying" && (
          <motion.div
            key={`now-playing-${nowPlayingCount}`}
            style={{
              position: "fixed",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              zIndex: 5,
              pointerEvents: "none",
            }}
            variants={nowPlayingVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            onAnimationComplete={(definition) => {
              if (definition === "visible") {
                handleAnimationComplete("nowPlaying");
              }
            }}
          >
            <motion.span
              style={{
                fontSize: "clamp(2rem, 8vw, 12rem)",
                fontWeight: "bold",
                color: "#fff",
                fontFamily: "Arial, sans-serif",
                letterSpacing: "0.2em",
                textAlign: "center",
                padding: "0 20px",
              }}
            >
              NOW PLAYING
            </motion.span>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Children контент */}
      <motion.div
        style={{
          position: "relative",
          zIndex: 1,
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        }}
        variants={childrenVariants}
        animate={
          animationStage === "showChildren" || animationStage === "idle"
            ? "visible"
            : "hidden"
        }
        onAnimationComplete={(definition) => {
          if (definition === "visible" && animationStage === "showChildren") {
            handleAnimationComplete("showChildren");
          }
        }}
      >
        {children}
      </motion.div>
    </AnimatedGradientBackground>
  );
}
</file>

<file path="src/components/SoundRequest/CurrentTrack/CurrentTrack.tsx">
import { TunaMusicData } from "../../../shared/api/generated/baza";
import AnimationControl from "./Animations/AnimationControl";
import styles from "./CurrentTrack.module.scss";
import { Textfit } from "react-textfit";

interface Props {
  track: TunaMusicData;
  shouldAnimate?: boolean;
}

export default function CurrentTrack({ track, shouldAnimate = true }: Props) {
  return (
    <AnimationControl AnimationStart={shouldAnimate}>
      <div className={styles.wrapper}>
        <div className={styles.container}>
          <div className={styles.main}>
            <div className={styles.cover}>
              {track.cover && <img src={track.cover} alt="Album cover" />}
            </div>
            <div className={styles.trackinfo}>
              <div className={styles.info}>
                <div className={styles.textContainer}>
                  <Textfit
                    mode="single"
                    max={200}
                    min={20}
                    style={{ width: '100%', height: '100%' }}
                  >
                    {track.artists.join(", ")}
                  </Textfit>
                </div>
                <div className={styles.textContainer}>
                  <Textfit
                    mode="single"
                    max={300}
                    min={30}
                    style={{ width: '100%', height: '100%' }}
                  >
                    {track.title}
                  </Textfit>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </AnimationControl>
  );
}
</file>

<file path="src/routes/LinkTree/LinkTreeMenu.css">
.linktree-container {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  text-align: center;
}

.linktree-container h1 {
  font-size: 24px;
  margin-bottom: 20px;
  color: white;
}

.links-grid {
  display: flex;
  flex-direction: column;
  align-items: center;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

.link-card {
  padding: 15px;
  background: #4a4a8a;
  width: 51%;
  color: white;
  text-decoration: none;
  border-radius: 8px;
  transition: background 0.3s;
}

.link-card:hover {
  background: #6a6aaa;
}
</file>

<file path="src/routes/LinkTree/LinkTreeMenu.tsx">
import { Link } from "react-router-dom";
import "./LinktreeMenu.css"; // Стили (можно заменить на Tailwind или styled-components)

export const LinktreeMenu = () => {
  const links = [
    { path: "/pyroalerts", name: "Pyro Alerts" },
    { path: "/randommem", name: "RandomMem" },
    { path: "/waifu", name: "Waifu Alerts" },
    { path: "/fumofriday", name: "Fumo Friday" },
    { path: "/highlite", name: "Highlite Message" },
    { path: "/confetti", name: "Confetti Manager" },
    { path: "/chath", name: "Horizontal Chat" },
    { path: "/chatv", name: "Vertical Chat" },
    { path: "/sr/currenttrack", name: "SR: Current Track" },
  ];

  return (
    <div className="linktree-container">
      <h1>Choose a Component</h1>
      <div className="links-grid">
        {links.map((link) => (
          <Link key={link.path} to={link.path} className="link-card">
            {link.name}
          </Link>
        ))}
      </div>
    </div>
  );
};
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
});
</file>

<file path="src/components/ChatHorizontal/ChatHorizontal.tsx">
import { Message } from "./Message";
import { SignalRContext } from "../../app";
import { ChatMessage } from "../../shared/api/generated/baza";
import { useCallback, useState } from "react";
import Announce from "../../shared/Utils/Announce/Announce";

export default function ChatHorizontal() {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [announced, setAnnounced] = useState(false);

  SignalRContext.useSignalREffect(
    "newmessage",
    (id: string, message: ChatMessage) => {
      message.id ??= id;
      setMessages((prev) => {
        while(prev.length >= 50) {
          prev.pop();
        }
        if (prev.find((m) => m.id === message.id)) {
          return prev;
        } else {
          return [message, ...prev];
        }
      });
    },
    [],
  );

  SignalRContext.useSignalREffect(
    "deletemessage",
    (id: string) => {
      setMessages((prev) => prev.filter((m) => m.id !== id));
    },
    [],
  );

  const remove = useCallback((message: ChatMessage) => {
    setMessages((prev) => prev.filter((m) => m.id !== message.id));
  }, []);

  return (
    <>
      {!announced && (
        <Announce
          title={"Chat Horizontal"}
          callback={() => setAnnounced(true)}
        />
      )}
      {messages.map((message) => {
        return (
          <Message
            key={message.id}
            message={message}
            callback={() => remove(message)}
          />
        );
      })}
    </>
  );
}
</file>

<file path="src/components/ChatHorizontal/Message.tsx">
import { useEffect, useRef, useState } from "react";
import styles from "./Message.module.css";
import {
  getNotWhiteColor,
  getRandomInt,
  isWhiteColor,
  parseContent,
  replaceEmotes,
} from "../../shared/Utils";
import { ChatMessage } from "../../shared/api/generated/baza";
import animateStyles from "../../shared/styles/animate.module.scss";
import { useAnimate } from "react-simple-animate";
import useTwitchStore from "../../shared/twitchStore/twitchStore";

interface Props {
  message: ChatMessage;
  callback?: () => void;
}

export const Message = ({ message, callback }: Props) => {
  const [handler, setHandler] = useState(true);
  const divRef = useRef<HTMLDivElement>(null);
  const parser = useTwitchStore((state) => state.parser);
  const parserToLink = useTwitchStore((state) => state.parseToLink);
  if (!parser || !parserToLink) return null;

  const [text] = useState(parseContent(message.message));
  const [fontSize, _] = useState(getRandomInt(10, 40));
  const [duration, __] = useState(fontSize * 0.7);
  const [opacity, ___] = useState(getRandomInt(0.4, 0.6));
  const [mainColor, ____] = useState(
    isWhiteColor(message.colorHex ?? "white")
      ? getNotWhiteColor(opacity)
      : (message.colorHex ?? "white"),
  );
  const [bg, _________] = useState(
    `linear-gradient(125deg, ${mainColor} , transparent 75%) border-box`,
  );
  const [baseStyles, setBaseStyles] = useState<React.CSSProperties>({
    visibility: "hidden",
    fontSize: fontSize + "px", // Случайный размер шрифта
    position: "absolute",
    background:
      message.isVip || message.isModerator || message.isBroadcaster
        ? bg
        : undefined,
    margin: fontSize / 10 + "px",
  });
  const [divOffset, setDivOffset] = useState(0);
  const { play, style } = useAnimate({
    duration: duration,
    start: {
      ...baseStyles,
      left: window.outerWidth + divOffset + "px",
    },
    end: {
      ...baseStyles,
      left: divOffset * -1 - 100 + "px",
    },
    onComplete: () => {
      setHandler(false);
    },
  });

  useEffect(() => {
    const elem = divRef.current!;
    const randPosY = Math.floor(
      Math.random() * (window.innerHeight - elem.offsetHeight),
    );

    // Устанавливаем анимацию через inline-стили
    setBaseStyles({
      ...baseStyles,
      top: randPosY + "px",
      visibility: "visible",
      left: window.outerWidth + "px",
    });
  }, [message.id]);

  useEffect(() => {
    if (divRef.current && divRef.current.offsetWidth) {
      setDivOffset(divRef.current.offsetWidth);

      setBaseStyles((prev) => ({
        ...prev,
        left: window.outerWidth + divOffset + "px",
      }));
    }

    if (divOffset !== 0) {
      play(true);
    }
  }, [divRef.current?.offsetWidth]);

  return (
    handler && (
      <div
        ref={divRef}
        key={message.id}
        style={style}
        className={styles.message + " " + animateStyles.animated}
        onAnimationEnd={callback}
      >
        <div
          id={`${message.id}_nickname`}
          className={styles.nickname}
          style={{ color: message.colorHex }}
        >
          {message.displayName}:
        </div>
        <div
          className={styles.text}
          style={{ color: "white", marginLeft: "10px" }}
        >
          {text?.map((part) => {
            switch (part.type) {
              case "text":
                return replaceEmotes({
                  text: message,
                  parser,
                  newParser: parserToLink,
                });
              case "image":
                return <span>Ссылка</span>;
              case "link":
                return <span>Ссылка</span>;
              case "video":
                return <span>Ссылка</span>;
            }
          })}
        </div>
      </div>
    )
  );
};
</file>

<file path="src/components/ChatVertical/ContentPart.tsx">
import { CSSProperties, JSX } from "react";
import type { ContentPart } from "../../shared/Utils";
import { Textfit } from "react-textfit";
import { ChatMessage } from "../../shared/api/generated/baza";

interface Props {
  className?: string;
  style?: CSSProperties;
  part: ContentPart;
  message: ChatMessage;
  convertMediaToJustLinks: boolean;
  replaceEmotes: ({
    message,
  }: {
    message?: string | ChatMessage;
  }) => string | JSX.Element | JSX.Element[] | undefined;
}

export default function ContentPiece({
  part,
  style,
  message,
  className,
  convertMediaToJustLinks,
  replaceEmotes,
}: Props) {
  if (convertMediaToJustLinks) {
    switch (part.type) {
      case "text":
        const text = replaceEmotes({ message: message });
        return (
          <Textfit
            min={1}
            max={10000}
            mode="multi"
            className={className}
            style={style}
          >
            {text}
          </Textfit>
        );

      default:
        return (
          <div className={className} style={style}>
            <span
              style={{
                color: "rgb(51, 255, 0);",
                textDecoration: "underline;",
                textDecorationColor: "rgb(38, 0, 255);",
              }}
            >
              Ссылка
            </span>
          </div>
        );
    }
  }
  switch (part.type) {
    case "text":
      const text = replaceEmotes({ message: message });

      return (
        <Textfit
          min={1}
          max={10000}
          mode="multi"
          className={className}
          style={style}
        >
          {text}
        </Textfit>
      );
    case "image":
      return (
        <div className={className} style={style}>
          <img
            src={part.content}
            className="image"
            loading="lazy"
            decoding="async"
          ></img>
        </div>
      );
    case "video":
      return (
        <div className={className} style={style}>
          <video src={part.content} className="video"></video>
        </div>
      );
    case "link":
      return (
        <div className={className} style={style}>
          <span
            style={{
              color: "rgb(51, 255, 0);",
              textDecoration: "underline;",
              textDecorationColor: "rgb(38, 0, 255);",
            }}
          >
            Ссылка
          </span>
        </div>
      );
  }
}
</file>

<file path="src/components/HighliteMessage/Message.tsx">
import { useCallback, useReducer, useRef } from "react";
import { Textfit } from "react-textfit";
import { useShallow } from "zustand/react/shallow";

import { SignalRContext } from "../../app";
import { ChatMessage, Image } from "../../shared/api/generated/baza";
import animate from "../../shared/styles/animate.module.scss";
import useTwitchStore from "../../shared/twitchStore/twitchStore";
import {
  getNotWhiteColor,
  isVideo,
  isWhiteColor,
  replaceBadges,
} from "../../shared/Utils";
import styles from "./Message.module.scss";

enum StateStatus {
  add,
  remove,
}

export interface HighliteMessageProps {
  message: ChatMessage;
  color: string;
  faceImage: Image;
}

interface State {
  messages: HighliteMessageProps[];
  currentMessage?: HighliteMessageProps;
  isMessageShowing: boolean;
}

function reducer(
  state: State,
  action: { type: StateStatus; messageProps: HighliteMessageProps },
): State {
  switch (action.type) {
    case StateStatus.add:
      if (!state.isMessageShowing) {
        return {
          messages: [...state.messages],
          currentMessage: action.messageProps,
          isMessageShowing: true,
        };
      }

      return { ...state, messages: [...state.messages, action.messageProps] };

    case StateStatus.remove:
      if (state.messages.length > 0) {
        const newArray = state.messages.filter(
          (message) => message.message.id !== action.messageProps.message.id,
        );

        if (newArray.length > 0) {
          const newMessage = newArray[0];

          return {
            messages: newArray,
            currentMessage: newMessage,
            isMessageShowing: true,
          };
        }

        return {
          messages: state.messages,
          currentMessage: undefined,
          isMessageShowing: false,
        };
      }

      return {
        currentMessage: undefined,
        isMessageShowing: false,
        messages: [],
      };
  }
}

export default function Message() {
  const [{ currentMessage }, dispatch] = useReducer(reducer, {
    messages: [],
    isMessageShowing: false,
  });
  const badges = useTwitchStore(useShallow((state) => state.badges));
  const divHard = useRef<HTMLDivElement>(null);

  SignalRContext.useSignalREffect(
    "Highlite",
    (message: ChatMessage, color: string, faceUrl: Image) => {
      dispatch({
        type: StateStatus.add,
        messageProps: { message, color, faceImage: faceUrl },
      });
    },
    [],
  );

  const handleRemoveEvent = useCallback((message: HighliteMessageProps) => {
    dispatch({ type: StateStatus.remove, messageProps: message });
  }, []);

  return (
    <>
      {currentMessage && (
        <div
          key={currentMessage.message.id}
          id={currentMessage.message.id}
          className={
            styles.container + " " + animate.fadeIn + " " + animate.animated
          }
          ref={divHard}
        >
          {/* IMAGE */}
          <div className={styles["buble-image"]}>
            {!isVideo(currentMessage) && (
              <img
                alt="Image"
                src={
                  import.meta.env.VITE_BASE_PATH + currentMessage.faceImage.url
                }
                onLoad={() => {
                  setTimeout(
                    () => {
                      divHard.current!.onanimationend = () => {
                        handleRemoveEvent(currentMessage);
                      };
                      divHard.current!.className =
                        styles.container +
                        " " +
                        animate.fadeOut +
                        " " +
                        animate.animated;
                    },
                    import.meta.env.DEV ? 99999 : 7000,
                  );
                }}
              />
            )}
            {isVideo(currentMessage) && (
              <video
                src={
                  import.meta.env.VITE_BASE_PATH + currentMessage.faceImage.url
                }
                autoPlay
                controls={false}
                loop
                muted
                onLoadedMetadata={() => {
                  setTimeout(
                    () => {
                      divHard.current!.onanimationend = () => {
                        handleRemoveEvent(currentMessage);
                      };
                      divHard.current!.className =
                        styles.container +
                        " " +
                        animate.fadeOut +
                        " " +
                        animate.animated;
                    },
                    import.meta.env.DEV ? 99999 : 7000,
                  );
                }}
              />
            )}
          </div>
          {/* TEXT */}
          <div
            className={styles.bubble + " " + styles.right}
            style={{
              background: `linear-gradient(135deg, ${isWhiteColor(currentMessage.color) ? getNotWhiteColor() : "white"}, ${currentMessage.color}) border-box`,
            }}
          >
            <div className={styles.talktext}>
              <div className={styles.icons}>
                <Textfit
                  min={1}
                  max={1500}
                  style={{
                    fontWeight: "bold",
                    color: `${currentMessage.color}`,
                  }}
                  mode="single"
                  forceSingleModeWidth
                  className={styles.name}
                >
                  {currentMessage.message.displayName}:
                </Textfit>
                <div>{replaceBadges(badges, currentMessage.message)}</div>
              </div>
              <Textfit
                min={1}
                max={1500}
                mode="multi"
                className={styles.emotes}
              >
                {currentMessage.message.message}
              </Textfit>
            </div>
          </div>
        </div>
      )}
    </>
  );
}
</file>

<file path="src/components/PyroAlerts/Alert.tsx">
import {
  MediaDto,
  MediaFileInfoTypeEnum,
} from "../../shared/api/generated/baza";
import { Audio, Image, Video, Voice } from "./Primitive";
import TelegramSticker from "./Primitive/TelegramSticker";

interface Props {
  message?: MediaDto;
  remove: (message: MediaDto) => void;
}

export default function Alert(messageProps: Props) {
  const message = messageProps.message;
  if (!message) return null;

  const { fileInfo } = message.mediaInfo;
  const callback = () => messageProps.remove(message);

  switch (fileInfo.type) {
    case MediaFileInfoTypeEnum.Image:
    case MediaFileInfoTypeEnum.Gif:
      return (
        <Image
          key={message.mediaInfo.id}
          mediaInfo={message}
          callBack={callback}
        />
      );
    case MediaFileInfoTypeEnum.Video:
      return (
        <Video
          key={message.mediaInfo.id}
          MediaInfo={message}
          callback={callback}
        />
      );
    case MediaFileInfoTypeEnum.Audio:
      return (
        <Audio
          key={message.mediaInfo.id}
          mediaInfo={message}
          callback={callback}
        />
      );
    case MediaFileInfoTypeEnum.Voice:
      return (
        <Voice
          key={message.mediaInfo.id}
          mediaInfo={message}
          callback={callback}
        />
      );
    case MediaFileInfoTypeEnum.TelegramSticker:
      return (
        <TelegramSticker
          key={message.mediaInfo.id}
          mediaInfo={message}
          callBack={callback}
        />
      );
    default:
      return null;
  }
}
</file>

<file path="src/components/PyroAlerts/Primitive/Audio.tsx">
import { useCallback, useRef } from "react";
import { MediaDto } from "../../../shared/api/generated/baza";
import { BigTextBlockForAudio } from "../../../shared/Utils/BigTexts/BigTextBlockForAudio";
import { SignalRContext } from "../../../app";

interface Props {
  callback: () => void;
  mediaInfo: MediaDto;
  isHighPrior?: boolean;
}

export function Audio({ mediaInfo, callback, isHighPrior }: Props) {
  const { fileInfo, id: Id } = mediaInfo.mediaInfo;

  const audioRef = useRef<HTMLAudioElement>(null);
  const divRef = useRef<HTMLDivElement>(null);

  const muteAll = useCallback(() => {
    if (isHighPrior) {
      SignalRContext.invoke("MuteAll", []);
    }
  }, []);

  const unmuteAll = useCallback(() => {
    if (isHighPrior) {
      SignalRContext.invoke("UnmuteSessions");
    }
  }, []);

  const error = useCallback(() => {
    unmuteAll();
    callback();
    throw Error("Failed to play audio");
  }, [callback]);

  return (
    <div ref={divRef} style={{ width: "100%" }}>
      <BigTextBlockForAudio mediaInfo={mediaInfo} />
      <audio
        id={Id}
        key={Id}
        ref={audioRef}
        controls={false}
        onError={(e) => {
          console.log(
            "%c" + e,
            "color: #7289DA; -webkit-text-stroke: 2px black; font-size: 72px; font-weight: bold;",
          );
          error();
        }}
        onEnded={() => {
          unmuteAll();
          setTimeout(() => {
            callback();
          }, 1000);
        }}
        onCanPlay={(event) => {
          event.currentTarget?.play();
        }}
        onCanPlayThrough={() => muteAll()}
      >
        <source src={fileInfo.filePath} />
      </audio>
    </div>
  );
}
</file>

<file path="src/components/PyroAlerts/Primitive/Image.tsx">
import { CSSProperties, useEffect, useRef, useState } from "react";

import { getCoordinates, getRandomRotation } from "../../../shared/Utils";
import styles from "./Media.module.scss";
import { MediaDto } from "../../../shared/api/generated/baza";

interface Props {
  callBack: () => void;
  mediaInfo: MediaDto;
}

export function Image({ mediaInfo: MediaInfo, callBack }: Props) {
  const mediaInfo = MediaInfo.mediaInfo;
  const fileInfo = mediaInfo.fileInfo;
  const id = mediaInfo.id;
  const metaInfo = mediaInfo.metaInfo;
  const textInfo = mediaInfo.textInfo;
  const positionInfo = mediaInfo.positionInfo;

  useEffect(() => {
    setTimeout(() => callBack(), metaInfo.duration * 1000);
  }, [callBack, metaInfo.duration]);

  const ref = useRef<HTMLDivElement>(null);

  const [style, setStyle] = useState<CSSProperties>({
    maxWidth: positionInfo.width + "px",
    maxHeight: positionInfo.height + "px",
    visibility: "hidden",
  });

  return (
    <div ref={ref} className={styles["imageContainer"]}>
      {positionInfo.isProportion ? (
        <img
          id={id}
          src={fileInfo.filePath}
          key={id}
          alt={"IMAGE ERROR"}
          className={styles.media}
          style={style}
          onLoad={(event) => {
            const cords = getCoordinates(event.currentTarget, mediaInfo);
            const rotation = getRandomRotation(mediaInfo);
            const size = { ...style };
            setStyle(() => {
              return { ...cords, ...rotation, ...size, visibility: "visible" };
            });
          }}
          onError={(e) => console.log(e)}
          onErrorCapture={(e) => console.log(e)}
        />
      ) : (
        <img
          id={id}
          src={fileInfo.filePath}
          key={id}
          alt={"IMAGE ERROR"}
          className={styles.media}
          style={style}
          onError={(e) => console.log("%c" + e, "color: #7289DA; -webkit-text-stroke: 2px black; font-size: 72px; font-weight: bold;")}
          onErrorCapture={(e) => console.log(e)}
          onLoad={(event) => {
            const cords = getCoordinates(event.currentTarget, mediaInfo);
            const rotation = getRandomRotation(mediaInfo);
            const size = { ...style };
            setStyle(() => {
              return { ...cords, ...rotation, ...size, visibility: "visible" };
            });
          }}
        />
      )}
      {textInfo.text !== "" && <div>{textInfo.text}</div>}
    </div>
  );
}
</file>

<file path="src/components/PyroAlerts/Primitive/Voice.tsx">
import { useCallback, useState } from "react";
import { MediaDto } from "../../../shared/api/generated/baza";
import { Container, Row } from "react-bootstrap";
import { Textfit } from "react-textfit";
import styles from "./Media.module.scss";
import { SignalRContext } from "../../../app";

interface Props {
  mediaInfo: MediaDto;
  callback: () => void;
  isHighPrior?: boolean;
}

export function Voice({ mediaInfo, callback, isHighPrior }: Props) {
  const { metaInfo, fileInfo, textInfo } = mediaInfo.mediaInfo;
  const bellSrc = import.meta.env.VITE_BASE_PATH + "Alerts/bell.wav";
  const voiceSrc = fileInfo.filePath;
  const imageSrc = import.meta.env.VITE_BASE_PATH + textInfo.text;

  const [isBellPlayed, setIsBellPlayed] = useState(false);

  const error = useCallback(() => {
    unmuteAll();
    callback();
    throw Error("Failed to play audio");
  }, [callback]);

  const muteAll = useCallback(() => {
    if (isHighPrior) {
      SignalRContext.invoke("MuteAll", []);
    }
  }, []);

  const unmuteAll = useCallback(() => {
    if (isHighPrior) {
      SignalRContext.invoke("UnmuteSessions");
    }
  }, []);

  return (
    <>
      {!isBellPlayed && (
        <audio
          autoPlay
          src={bellSrc}
          onEnded={() => setIsBellPlayed(true)}
          onError={() => error()}
          onErrorCapture={() => error()}
          onCanPlayThrough={muteAll}
        />
      )}
      {isBellPlayed && (
        <audio
          autoPlay
          src={voiceSrc}
          onEnded={() => {
            unmuteAll();
            callback();
          }}
          onError={() => error()}
          onErrorCapture={() => error()}
        />
      )}
      {
        <Container className={styles.container}>
          <Row className={styles.block}>
            <Textfit forceSingleModeWidth max={2000} min={1}>
              всем тихо
            </Textfit>
          </Row>
          <Row className={styles.block_image}>
            <img src={import.meta.env.VITE_BASE_PATH + "Alerts/mute.png"} />
          </Row>
          <Row className={styles.block}>
            <Textfit forceSingleModeWidth max={2000} min={1}>
              Сейчас говорит <img className="emote" src={imageSrc} />
              {metaInfo.displayName}
            </Textfit>
          </Row>
        </Container>
      }
    </>
  );
}
</file>

<file path="src/components/ScreenParticles/Manager.tsx">
import { useCallback, useState } from "react";
import { SignalRContext } from "../../app";
import {
  ChatMessage,
  MakeScreenParticlesCreateParamsParticlesEnum,
} from "../../shared/api/generated/baza";
import { Confettyv2 } from "./Confetty";
import EmojiParticles from "./EmojiParticles";
import Firework from "./Firework";

interface base {
  id: number;
}

interface particles extends base {
  type: MakeScreenParticlesCreateParamsParticlesEnum;
}

interface emojis extends base {
  input: string | ChatMessage;
}

export default function Manager() {
  const [count, setCount] = useState<number>(0);
  const [messages, setMessages] = useState<particles[]>([]);
  const [emojis, setEmojis] = useState<emojis[]>([]);

  SignalRContext.useSignalREffect(
    "MakeScreenParticles",
    (type: MakeScreenParticlesCreateParamsParticlesEnum) => {
      const newMessage = { type: type, id: count };
      setCount(count + 1);
      setMessages((prev) => [...prev, newMessage]);
    },
    [],
  );

  SignalRContext.useSignalREffect(
    "MakeScreenEmojisParticles",
    (mediaDto: ChatMessage) => {
      const newMessage = { input: mediaDto, id: count };
      setCount(count + 1);
      setEmojis((prev) => [...prev, newMessage]);
    },
    [],
  );

  const removeMessage = useCallback((id: number) => {
    setMessages((prev) => {
      return prev.filter((message) => message.id !== id);
    });
  }, []);

  return (
    <>
      {messages.length > 0 &&
        messages.map((message) => {
          switch (message.type) {
            case MakeScreenParticlesCreateParamsParticlesEnum.Confetty:
              return (
                <Confettyv2
                  key={message.id}
                  callback={() => removeMessage(message.id)}
                />
              );
            case MakeScreenParticlesCreateParamsParticlesEnum.Fireworks:
              return (
                <Firework
                  key={message.id}
                  callback={() => removeMessage(message.id)}
                />
              );
          }
        })}
      {emojis.length > 0 &&
        emojis.map((message) => {
          return <EmojiParticles key={message.id} input={message.input} />;
        })}
    </>
  );
}
</file>

<file path="src/components/SoundRequest/CurrentTrack/CurrentTrack.module.scss">
/* Animation.module.scss */
.slide {
  height: 100%;
  background: linear-gradient(80deg, red 0%, red 100%);
  border-radius: 0;
  transition: height 0.5s ease;
}

/* CurrentTrack.module.scss */
.wrapper {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 5vw;
}

.container {
  display: flex;
  flex-direction: column;
  position: relative;
  width: 100%;
  height: 100%;
  max-width: 90vw;
  max-height: 90vh;
}

.main {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  gap: 5vw;
}

.cover {
  display: flex;
  border-radius: 2vw;
  width: 40vw;
  height: 40vw;
  max-width: 500px;
  max-height: 500px;
  min-width: 200px;
  min-height: 200px;
  z-index: 2;
  aspect-ratio: 1/1;
  animation: pulse 3s infinite;

  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 2vw;
  }
}

.trackinfo {
  flex: 1;
  height: 100%;
  min-width: 0;
  z-index: 1;
}

.info {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 3vw;
}

.textContainer {
  display: flex;
  overflow: hidden;
  text-align: center;
  width: 100%;
  white-space: nowrap;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-weight: bold;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  
  /* Адаптивные размеры текста */
  font-size: clamp(1.5rem, 4vw, 6rem);
  line-height: 1.2;

  &:first-child{
    color: #e2df13;
  }
}

/* Адаптивность для мобильных устройств */
@media (max-width: 768px) {
  .main {
    flex-direction: column;
    gap: 3vh;
  }
  
  .cover {
    width: 50vw;
    height: 50vw;
    max-width: 300px;
    max-height: 300px;
  }
  
  .textContainer {
    font-size: clamp(1rem, 6vw, 4rem);
  }
}

@media (max-height: 600px) {
  .main {
    flex-direction: row;
  }
  
  // .cover {
  //   width: 30vh;
  //   height: 30vh;
  // }
}

/* Анимации */
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}
</file>

<file path="src/shared/twitchStore/twitchStore.ts">
import emoticons from "@mkody/twitch-emoticons";
import type {} from "@redux-devtools/extension";
import { ApiClient, HelixChatBadgeSet } from "@twurple/api";
import { AppTokenAuthProvider } from "@twurple/auth";
import { ChatMessage } from "@twurple/chat";
import { create } from "zustand";
import { devtools } from "zustand/middleware";

import { SignalRContext } from "../../app";

interface Actions {
  init: (clientId: string, clientSecret: string) => void;
  setBadges: (badges: HelixChatBadgeSet[]) => void;
  parse: (text: string, size?: number) => string;
  sendMsgToPyrokxnezxz: (msg: string) => Promise<void>;
}

interface State {
  fetcher?: emoticons.EmoteFetcher;
  parser?: emoticons.EmoteParser;
  parseToLink?: emoticons.EmoteParser;
  badges: HelixChatBadgeSet[];
  twitchApiClient?: ApiClient;
  twitchMessages: ChatMessage[];
}

const initialState: State = {
  badges: [],
  twitchMessages: [],
};

export const useTwitchStore = create<State & Actions>()(
  devtools((set) => ({
    ...initialState,
    init: (clientId: string, clientSecret: string) => {
      const { client, fetcher, parser, newParser } = initialization(
        clientId,
        clientSecret,
      );
      getBadges(client)
        .then((badges) => set({ badges }))
        .catch((err) => {
          console.error(err);
          set({ badges: [] });
        });

      Promise.all([
        // Twitch global
        fetcher.fetchTwitchEmotes(),
        // Twitch channel
        fetcher.fetchTwitchEmotes(785975641),
        //BTTV global
        fetcher.fetchBTTVEmotes(),
        // 7TV global
        fetcher.fetchSevenTVEmotes(),
        // 7TV channel
        fetcher.fetchSevenTVEmotes(785975641),
        // FFZ global
        fetcher.fetchFFZEmotes(),
      ])
        .then(() => {
          console.log("Emotes loaded");
          set({
            fetcher,
            parser,
            twitchApiClient: client,
            parseToLink: newParser,
          });
        })
        .catch((err) => {
          console.error("Error loading emotes...");
          console.error(err);
          set({
            fetcher,
            parser,
            twitchApiClient: client,
            parseToLink: newParser,
          });
        });
    },
    sendMsgToPyrokxnezxz: async (msg: string) => {
      await SignalRContext.invoke("TwitchMsg", msg);
    },
  })),
);

function initialization(clientId: string, clientSecret: string) {
  const provider = new AppTokenAuthProvider(clientId, clientSecret);
  const client = new ApiClient({ authProvider: provider });
  const fetcher = new emoticons.EmoteFetcher(undefined, undefined, {
    apiClient: client,
  });
  const parser = new emoticons.EmoteParser(fetcher, {
    template: '<img class="emote" alt="{name}" src="{link}" />',
    match: /(\w+)+?/g,
  });

  var newParser = new emoticons.EmoteParser(fetcher, {
    template: '<img class="emote" alt="{name}" src="{link}" />',
    match: /(?<!<[^>]*)(\w+)(?![^<]*>)/g,
  });

  return { fetcher, parser, client, newParser };
}

async function getBadges(apiClient: ApiClient) {
  const badges = await apiClient.chat.getChannelBadges(785975641);
  const globalBadges: HelixChatBadgeSet[] =
    await apiClient.chat.getGlobalBadges();

  const result = [...badges, ...globalBadges];
  return result;
}

export default useTwitchStore;
</file>

<file path="src/shared/Utils/BigTexts/BigTextBlockForAudio.tsx">
import { JSX } from "react";
import { Container, Row } from "react-bootstrap";
import { Textfit } from "react-textfit";

import { replaceEmotes } from "..";
import { MediaDto } from "../../api/generated/baza";
import styles from "./BigTextStyles.module.scss";
import useTwitchStore from "../../twitchStore/twitchStore";

interface Props {
  mediaInfo: MediaDto;
}

export function BigTextBlockForAudio({ mediaInfo }: Props) {
  const parser = useTwitchStore((state) => state.parser);
  const parserToLink = useTwitchStore((state) => state.parseToLink);
  const text = mediaInfo.mediaInfo.textInfo.text;

  if (text === null && text === "") {
    return undefined;
  }

  if (!parser || !parserToLink) {
    return undefined;
  }

  const splits = text?.split("=");

  const length = splits?.length;

  if (!length) {
    return null;
  } else if (length && length > 2) {
    console.error("Дохуя разделителей в тексте алерта");
    return null;
  }

  const emotesSplits: Array<string | JSX.Element | JSX.Element[]> = [];
  for (let i = 0; i < splits.length; i++) {
    splits[i] = splits[i].trim();
    if (splits[i]) {
      const result = replaceEmotes({
        text: splits[i],
        parser,
        newParser: parserToLink,
      });
      if (result) {
        emotesSplits[i] = result;
      }
    }
  }

  const is2Exists = splits[1] != undefined && emotesSplits[1] != undefined;

  return (
    <Container className={styles.grid}>
      <Row className={styles.grid_cell}>
        <Textfit
          forceSingleModeWidth
          style={{
            width: "100%",
            height: "100%",
            marginLeft: "auto",
            marginRight: "auto",
            textAlign: "center",
            display: "flex",
            justifyContent: "center",
            alignContent: "center",
            flexWrap: "nowrap",
            alignItems: "stretch",
          }}
          max={2000}
        >
          {emotesSplits[0]}
        </Textfit>
      </Row>
      <Row className={styles.grid_cell}></Row>
      <Row className={styles.grid_cell}></Row>
      <Row className={styles.grid_cell}></Row>
      <Row
        className={
          styles.grid_cell + ` down-cell ${is2Exists ? " bg-black" : ""}`
        }
      >
        <Textfit
          forceSingleModeWidth
          style={{
            width: "100%",
            height: "100%",
            marginLeft: "auto",
            marginRight: "auto",
            textAlign: "center",
            display: "flex",
            justifyContent: "center",
            alignContent: "center",
            flexWrap: "nowrap",
            alignItems: "stretch",
          }}
          max={2000}
        >
          {is2Exists ? emotesSplits[1] : ""}
        </Textfit>
      </Row>
    </Container>
  );
}
</file>

<file path="src/components/ChatVertical/Message.module.scss">
.container {
  display: flex;
  flex-direction: column;
  min-height: 100px; /* Минимальная высота */
  padding: 5px 10px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  margin-top: 1vh;
}

.head {
  display: flex;
  align-items: center; // Выравнивание по вертикали
  margin-bottom: 5px; // Отступ между заголовком и сообщением
}

.badgesAndNickname {
  display: flex;
  flex-grow: 1;
  align-items: stretch; // Бейджики и никнейм на одной строке
  justify-items: stretch;
  gap: 8px; // Расстояние между бейджиками и никнеймом
  height: 50px;
  margin-bottom: 1px;
  margin-right: 1svw;
}

.badges {
  display: flex;
  align-items: center;
  gap: 4px; // Расстояние между бейджиками

  > img {
    max-height: 40px;
    max-width: 40px;
  }
}

.nickname {
  display: flex;
  align-self: stretch;
  text-align: center;
  align-items: flex-end;
  max-height: 40px;
  font-weight: bold;
  white-space: nowrap; // Запрет переноса текста
  width: -webkit-fill-available;
}

.messageWrapper {
  flex-grow: 1; // Растягивает контейнер на всю доступную высоту
  overflow: hidden; // Скрывает содержимое, выходящее за пределы контейнера
  display: flex;
  flex-direction: column;
  align-items: flex-start; // Выравнивание текста по центру по вертикали
  justify-content: left; // Выравнивание текста по центру по горизонтали
  min-height: 20px;
  height: 90px;
}

.message {
  width: 100vw; // Сообщение занимает всю ширину контейнера
  word-wrap: break-word; // Перенос длинных слов
  text-align: left; // Текст по центру
  color: white;
  flex-grow: 1;

  > img {
    overflow: hidden;
    height: -webkit-fill-available;
  }

  > div {
    height: 100%;

    > img {
      height: 1em;
      width: auto;
      object-fit: cover;
      vertical-align: middle;
    }
  }
}
</file>

<file path="src/components/PyroAlerts/Primitive/TelegramSticker.tsx">
import { createComponent } from "@lit/react";
import { TGSPlayer } from "@lottiefiles/lottie-player/dist/tgs-player";
import { useEffect, useRef, useState } from "react";
// eslint-disable-next-line no-restricted-imports
import react from "react";
import { getCoordinates, getRandomRotation } from "../../../shared/Utils";
import { MediaDto } from "../../../shared/api/generated/baza";
import { replaceEmotes } from "../../../shared/Utils";
import styles from "./Media.module.scss";
import useTwitchStore from "../../../shared/twitchStore/twitchStore";

const Player = createComponent({
  elementClass: TGSPlayer,
  react: react,
  tagName: "tgs-player",
  displayName: "tgs-player",
});

interface Props {
  callBack: () => void;
  mediaInfo: MediaDto;
}

export default function TelegramSticker({
  mediaInfo,
  callBack,
}: Props) {
  const {
    id: Id,
    metaInfo,
    positionInfo,
    textInfo,
    fileInfo,
  } = mediaInfo.mediaInfo;
  const parser = useTwitchStore((state) => state.parser);
  const parserToLInk = useTwitchStore((state) => state.parseToLink);

  const [style, setStyle] = useState<React.CSSProperties>(
    positionInfo.isProportion
      ? {
          maxWidth: positionInfo.width + "px",
          maxHeight: positionInfo.height + "px",
        }
      : {
          width: positionInfo.width + "px",
          height: positionInfo.height + "px",
          maxHeight: "max-content",
        },
  );

  const elementRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    setTimeout(() => callBack(), metaInfo.duration * 1000);
  }, [callBack, metaInfo.duration]);

  useEffect(() => {
    if (elementRef.current) {
      const cords = getCoordinates(elementRef.current, mediaInfo.mediaInfo);
      const rotation = getRandomRotation(mediaInfo.mediaInfo);
      setStyle(prev => ({
        ...prev,
        ...cords,
        ...rotation,
        visibility: "visible",
      }));
    }
  }, [mediaInfo.mediaInfo]);

  if (!parser || !parserToLInk) {
    return null;
  }

  return (
    <div
      id={Id}
      key={Id}
      className={styles.media}
      style={style}
      ref={elementRef}
    >
      <Player
        autoplay
        loop
        src={fileInfo.filePath}
        style={{ width: "320px", height: "320px" }}
        background="transparent"
      />
      <div className="sticker-text">
        {replaceEmotes({
          text: textInfo.text,
          parser,
          newParser: parserToLInk,
        })}
      </div>
    </div>
  );
}
</file>

<file path="src/app/main.tsx">
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";

import App from "./App.tsx";
import { SignalRContext } from "./index.ts";
import { ILogger } from "react-signalr";

const LogLevelNames = {
  [0]: "Trace",
  [1]: "Debug",
  [2]: "Information",
  [3]: "Warning",
  [4]: "Error",
  [5]: "Critical",
  [6]: "None",
} as const;

type LogLevel = keyof typeof LogLevelNames;

export const logger: ILogger = {
  log: (level: number, message: string) => {
    if (!(level in LogLevelNames)) {
      console.log("%cUnknown level:", "color: red;", message);
      return;
    }

    const levelName = LogLevelNames[level as LogLevel];
    const levelColor = getLevelColor(level);

    // Пытаемся найти и распарсить JSON (для WebSocket)
    const jsonData = tryParseJson(message);

    if (jsonData) {
      // Если это JSON - выводим как объект с подсветкой
      console.log(
        `%c${levelName}:%c (JSON)`,
        `color: ${levelColor}; font-weight: bold;`,
        "color: gray;",
        jsonData,
      );
    } else {
      // Обычное сообщение
      console.log(
        `%c${levelName}:%c`,
        `color: ${levelColor}; font-weight: bold;`,
        "color: inherit;",
        message,
      );
    }
  },
};

// Вспомогательные функции
function tryParseJson(str: string): any {
  try {
    // Ищем JSON в строках вида: Content: '{"protocol":"json"}'
    const jsonMatch = str.match(/Content: '(.*?)[\u001E']/);
    const jsonString = jsonMatch?.[1] || str;

    return JSON.parse(jsonString);
  } catch {
    return null;
  }
}

function getLevelColor(level: number): string {
  switch (level) {
    case 0:
      return "#9E9E9E"; // Trace - серый
    case 1:
      return "#4CAF50"; // Debug - зеленый
    case 2:
      return "#2196F3"; // Info - синий
    case 3:
      return "#FFC107"; // Warning - желтый
    case 4:
      return "#F44336"; // Error - красный
    case 5:
      return "#9C27B0"; // Critical - фиолетовый
    default:
      return "#34aeeb";
  }
}

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <SignalRContext.Provider
      automaticReconnect={true}
      onError={(error) => new Promise((resolve) => resolve(console.log(error)))}
      onClosed={(event) => console.log(event)}
      onOpen={(event) => console.log(event)}
      logger={logger}
      withCredentials={false}
      url={import.meta.env.VITE_BASE_PATH + "telegramus"}
      logMessageContent
    >
      <App />
    </SignalRContext.Provider>
  </StrictMode>,
);
</file>

<file path="src/components/ChatVertical/ChatVertical.module.scss">
// ChatVertical.module.scss
.chatContainer {
  position: relative;
  display: flex;
  flex-direction: column-reverse; // Убрали reverse
  min-height: 100vh;
  width: 100vw;
  overflow-y: hidden;
  gap: 2.5%;
  margin: 1px;
  left: 0;
  bottom: 0;
  box-sizing: content-box;
  justify-content: flex-start; // Добавили это, чтобы контент прижимался к низу
}

.chatContainer::-webkit-scrollbar {
  display: none;
}
</file>

<file path="src/components/ChatVertical/ChatVertical.tsx">
import { Message } from "./Message";
import { SignalRContext } from "../../app";
import { ChatMessage } from "../../shared/api/generated/baza";
import { useEffect, useRef, useState } from "react";
import Announce from "../../shared/Utils/Announce/Announce";
import styles from "./ChatVertical.module.scss";

export default function ChatVertical() {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [announced, setAnnounced] = useState(false);

  SignalRContext.useSignalREffect(
    "newmessage",
    (id: string, message: ChatMessage) => {
      message.id ??= id;
      setMessages((prev) => {
        while (prev.length >= 15) {
          prev.pop();
        }
        if (prev.find((m) => m.id === message.id)) {
          return prev;
        } else {
          return [message, ...prev];
        }
      }); // Изменено: добавляем в конец
    },
    [],
  );

  SignalRContext.useSignalREffect(
    "deletemessage",
    (id: string) => {
      setMessages((prev) => prev.filter((m) => m.id !== id));
    },
    [],
  );

  return (
    <>
      {!announced && (
        <Announce title={"Chat Vertical"} callback={() => setAnnounced(true)} />
      )}
      <div className={styles.chatContainer}>
        {messages.map((message) => (
          <Message key={message.id} message={message} />
        ))}
      </div>
      <ScrollToBottom />
    </>
  );
}

function ScrollToBottom() {
  const elementRef = useRef<HTMLDivElement>(null);
  useEffect(() => elementRef.current!.scrollIntoView());
  return <div ref={elementRef} />;
}
</file>

<file path="src/shared/api/generated/baza.ts">
/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export interface BaseTrackInfo {
    authors: string[] | undefined;
    /** @format date-span */
    duration: string;
    featAuthors: string[] | undefined;
    genre: string[] | undefined;
    /** @format uuid */
    id: string;
    /** @format date-time */
    lastTimePlays: string;
    title: string;
    trackName: string;
    url: string;
}

export interface ChatMessage {
    badgeInfo: StringStringKeyValuePair[] | undefined;
    badges: StringStringKeyValuePair[] | undefined;
    /** @format int32 */
    bits: number;
    /** @format double */
    bitsInDollars: number;
    botUsername: string | undefined;
    channel: string | undefined;
    chatReply: ChatReply | undefined;
    cheerBadge: CheerBadge | undefined;
    color: Color;
    colorHex: string | undefined;
    customRewardId: string | undefined;
    displayName: string | undefined;
    emoteReplacedMessage: string | undefined;
    emoteSet: EmoteSet | undefined;
    id: string | undefined;
    isBroadcaster: boolean;
    isFirstMessage: boolean;
    isHighlighted: boolean;
    isMe: boolean;
    isModerator: boolean;
    isPartner: boolean;
    isSkippingSubMode: boolean;
    isStaff: boolean;
    isSubscriber: boolean;
    isTurbo: boolean;
    isVip: boolean;
    message: string | undefined;
    noisy: ChatMessageNoisyEnum;
    rawIrcMessage: string | undefined;
    roomId: string | undefined;
    /** @format int32 */
    subscribedMonthCount: number;
    tmiSentTs: string | undefined;
    userId: string | undefined;
    userType: ChatMessageUserTypeEnum;
    username: string | undefined;
}

export enum ChatMessageNoisyEnum {
    NotSet = "NotSet",
    True = "True",
    False = "False",
}

export enum ChatMessageUserTypeEnum {
    Viewer = "Viewer",
    Moderator = "Moderator",
    GlobalModerator = "GlobalModerator",
    Broadcaster = "Broadcaster",
    Admin = "Admin",
    Staff = "Staff",
}

export interface ChatReply {
    parentDisplayName: string | undefined;
    parentMsgBody: string | undefined;
    parentMsgId: string | undefined;
    parentUserId: string | undefined;
    parentUserLogin: string | undefined;
}

export interface CheerBadge {
    /** @format int32 */
    cheerAmount: number;
    color: CheerBadgeColorEnum;
}

export enum CheerBadgeColorEnum {
    Gray = "Gray",
    Purple = "Purple",
    Green = "Green",
    Blue = "Blue",
    Red = "Red",
}

export interface Color {
    /** @format int32 */
    a: number;
    /** @format int32 */
    b: number;
    /** @format int32 */
    g: number;
    isEmpty: boolean;
    isKnownColor: boolean;
    isNamedColor: boolean;
    isSystemColor: boolean;
    name: string;
    /** @format int32 */
    r: number;
}

export interface Emote {
    /** @format int32 */
    endIndex: number;
    id: string | undefined;
    imageUrl: string | undefined;
    name: string | undefined;
    /** @format int32 */
    startIndex: number;
}

export interface EmoteSet {
    emotes: Emote[] | undefined;
    rawEmoteSetString: string | undefined;
}

export interface Image {
    artist: any;
    /** @format int32 */
    byteSize: number;
    dominantColor: string | undefined;
    extension: string | undefined;
    /** @format int32 */
    favorites: number;
    /** @format int32 */
    height: number;
    /** @format int32 */
    imageID: number;
    isNsfw: boolean;
    likedAt: any;
    previewURL: string | undefined;
    signature: string | undefined;
    source: string | undefined;
    /** @format date-time */
    uploadedAt: string;
    url: string | undefined;
    /** @format int32 */
    width: number;
}

export enum MakeScreenParticlesCreateParamsParticlesEnum {
    Confetty = "Confetty",
    Fireworks = "Fireworks",
}

export interface MediaDto {
    mediaInfo: MediaInfo;
    /** @format date-time */
    uploadStartTime: string;
}

export interface MediaFileInfo {
    extension: string;
    fileName: string;
    filePath: string;
    isLocalFile: boolean;
    type: MediaFileInfoTypeEnum;
}

export enum MediaFileInfoTypeEnum {
    None = "None",
    Image = "Image",
    Audio = "Audio",
    Video = "Video",
    TelegramSticker = "TelegramSticker",
    Voice = "Voice",
    Gif = "Gif",
}

export interface MediaInfo {
    fileInfo: MediaFileInfo;
    /** @format uuid */
    id: string;
    metaInfo: MediaMetaInfo;
    positionInfo: MediaPositionInfo;
    stylesInfo: MediaStylesInfo;
    textInfo: MediaTextInfo;
}

export interface MediaMetaInfo {
    displayName: string;
    /** @format int32 */
    duration: number;
    isLooped: boolean;
    priority: MediaMetaInfoPriorityEnum;
    /** @format uuid */
    twitchGuid: string | undefined;
    /** @format int32 */
    twitchPointsCost: number;
    vip: boolean;
}

export enum MediaMetaInfoPriorityEnum {
    Low = "Low",
    Normal = "Normal",
    High = "High",
}

export interface MediaPositionInfo {
    /** @format int32 */
    height: number;
    isHorizontalCenter: boolean;
    isProportion: boolean;
    isResizeRequires: boolean;
    isRotated: boolean;
    isUseOriginalWidthAndHeight: boolean;
    isVerticallCenter: boolean;
    randomCoordinates: boolean;
    /** @format int32 */
    rotation: number;
    /** @format int32 */
    width: number;
    /** @format int32 */
    xCoordinate: number;
    /** @format int32 */
    yCoordinate: number;
}

export interface MediaStylesInfo {
    isBorder: boolean;
}

export interface MediaTextInfo {
    keyWordSybmolDelimiter: string | undefined;
    keyWordsColor: string | undefined;
    text: string | undefined;
    textColor: string | undefined;
    triggerWord: string | undefined;
}

export interface PrizeType {
    id: string;
    image: string;
    text: string;
}

export interface StringStringKeyValuePair {
    key: string | undefined;
    value: string | undefined;
}

export interface TunaMusicDTO {
    data: TunaMusicData;
    hostname: string | undefined;
    timestamp: string | undefined;
}

export interface TunaMusicData {
    album_url: string;
    artists: string[];
    cover: string;
    /** @format int64 */
    duration: number;
    /** @format int64 */
    progress: number;
    status: string;
    title: string;
}

export interface Waifu {
    /** @format int64 */
    age: number;
    anime: string | undefined;
    /**
     * @minLength 1
     * @maxLength 200
     */
    imageUrl: string;
    isAdded: boolean;
    isMerged: boolean;
    isPrivated: boolean;
    /** @format date-time */
    lastOrder: string;
    manga: string | undefined;
    /**
     * @minLength 1
     * @maxLength 200
     */
    name: string;
    /** @format int32 */
    orderCount: number;
    /**
     * @minLength 1
     * @maxLength 20
     */
    shikiId: string;
    /** @format date-time */
    whenAdded: string;
}
</file>

<file path="api/swagger.json">
{
  "openapi": "3.0.4",
  "info": {
    "title": "Telegramus Open Api v3",
    "version": "v1"
  },
  "paths": {
    "/-/{controller}/endpoints": {
      "get": {
        "tags": [
          "Info"
        ],
        "parameters": [
          {
            "name": "controller",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/memory/{escapedFileName}": {
      "get": {
        "tags": [
          "PyroAlerts"
        ],
        "parameters": [
          {
            "name": "escapedFileName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/twitchtoken": {
      "get": {
        "tags": [
          "Twitch"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/hubs/SoundRequestHub/Ended": {
      "post": {
        "tags": [
          "SoundRequestHub"
        ],
        "parameters": [
          {
            "name": "trackInfo",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/BaseTrackInfo"
            }
          }
        ],
        "responses": { }
      }
    },
    "/hubs/SoundRequestHub/ErrorPlaying": {
      "post": {
        "tags": [
          "SoundRequestHub"
        ],
        "parameters": [
          {
            "name": "trackInfo",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/BaseTrackInfo"
            }
          }
        ],
        "responses": { }
      }
    },
    "/hubs/SoundRequestHub/JoinAsClient": {
      "post": {
        "tags": [
          "SoundRequestHub"
        ],
        "responses": { }
      }
    },
    "/hubs/SoundRequestHub/Started": {
      "post": {
        "tags": [
          "SoundRequestHub"
        ],
        "parameters": [
          {
            "name": "trackInfo",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/BaseTrackInfo"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/MuteAll": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "args",
            "in": "query",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/OnConnectedAsync": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "responses": { }
      }
    },
    "/telegramus/TwitchMsg": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "msg",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/UnmuteSessions": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "responses": { }
      }
    },
    "/hubs/TunaHub/SendPlayerData": {
      "post": {
        "tags": [
          "TunaHub"
        ],
        "parameters": [
          {
            "name": "info",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/TunaMusicDTO"
            }
          }
        ],
        "responses": { }
      }
    },
    "/hubs/SoundBarHub/Mute": {
      "post": {
        "tags": [
          "SoundBarHub"
        ],
        "parameters": [
          {
            "name": "args",
            "in": "query",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": { }
      }
    },
    "/hubs/SoundBarHub/Unmute": {
      "post": {
        "tags": [
          "SoundBarHub"
        ],
        "responses": { }
      }
    },
    "/telegramus/AddNewWaifu": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/Waifu"
            }
          },
          {
            "name": "displayName",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "color",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/Alert": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "info",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/MediaDto"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/Alerts": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "info",
            "in": "query",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/MediaDto"
              }
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/DeleteMessage": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/FumoFriday": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "displayName",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "color",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/Highlite": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "message",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/ChatMessage"
            }
          },
          {
            "name": "color",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "faceUrl",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/Image"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/MakeScreenEmojisParticles": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "message",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/ChatMessage"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/MakeScreenParticles": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "particles",
            "in": "query",
            "schema": {
              "enum": [
                "Confetty",
                "Fireworks"
              ],
              "type": "string"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/MergeWaifu": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/Waifu"
            }
          },
          {
            "name": "displayName",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "avatar",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "color",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/NewMessage": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "message",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/ChatMessage"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/PostTwitchInfo": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "clientId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "secret",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/RandomMem": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "mediaInfo",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/MediaDto"
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/UpdateWaifuPrizes": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "prizes",
            "in": "query",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/PrizeType"
              }
            }
          }
        ],
        "responses": { }
      }
    },
    "/telegramus/WaifuRoll": {
      "post": {
        "tags": [
          "TelegramusHub"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/Waifu"
            }
          },
          {
            "name": "displayName",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "color",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": { }
      }
    }
  },
  "components": {
    "schemas": {
      "BaseTrackInfo": {
        "required": [
          "duration",
          "id",
          "lastTimePlays",
          "title",
          "trackName",
          "url"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "trackName": {
            "type": "string"
          },
          "authors": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "featAuthors": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "duration": {
            "type": "string",
            "format": "date-span"
          },
          "genre": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "url": {
            "type": "string"
          },
          "lastTimePlays": {
            "type": "string",
            "format": "date-time"
          },
          "title": {
            "type": "string",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ChatMessage": {
        "required": [
          "bits",
          "bitsInDollars",
          "color",
          "isBroadcaster",
          "isFirstMessage",
          "isHighlighted",
          "isMe",
          "isModerator",
          "isPartner",
          "isSkippingSubMode",
          "isStaff",
          "isSubscriber",
          "isTurbo",
          "isVip",
          "noisy",
          "subscribedMonthCount",
          "userType"
        ],
        "type": "object",
        "properties": {
          "badges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StringStringKeyValuePair"
            },
            "nullable": true,
            "readOnly": true
          },
          "botUsername": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "color": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Color"
              }
            ],
            "readOnly": true
          },
          "colorHex": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "emoteSet": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EmoteSet"
              }
            ],
            "nullable": true,
            "readOnly": true
          },
          "isTurbo": {
            "type": "boolean",
            "readOnly": true
          },
          "userId": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "username": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "userType": {
            "enum": [
              "Viewer",
              "Moderator",
              "GlobalModerator",
              "Broadcaster",
              "Admin",
              "Staff"
            ],
            "type": "string",
            "readOnly": true
          },
          "rawIrcMessage": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "badgeInfo": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StringStringKeyValuePair"
            },
            "nullable": true,
            "readOnly": true
          },
          "bits": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "bitsInDollars": {
            "type": "number",
            "format": "double",
            "readOnly": true
          },
          "channel": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "cheerBadge": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CheerBadge"
              }
            ],
            "nullable": true,
            "readOnly": true
          },
          "customRewardId": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "emoteReplacedMessage": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "id": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "isBroadcaster": {
            "type": "boolean",
            "readOnly": true
          },
          "isFirstMessage": {
            "type": "boolean",
            "readOnly": true
          },
          "isHighlighted": {
            "type": "boolean",
            "readOnly": true
          },
          "isMe": {
            "type": "boolean",
            "readOnly": true
          },
          "isModerator": {
            "type": "boolean",
            "readOnly": true
          },
          "isSkippingSubMode": {
            "type": "boolean",
            "readOnly": true
          },
          "isSubscriber": {
            "type": "boolean",
            "readOnly": true
          },
          "isVip": {
            "type": "boolean",
            "readOnly": true
          },
          "isStaff": {
            "type": "boolean",
            "readOnly": true
          },
          "isPartner": {
            "type": "boolean",
            "readOnly": true
          },
          "message": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "noisy": {
            "enum": [
              "NotSet",
              "True",
              "False"
            ],
            "type": "string",
            "readOnly": true
          },
          "roomId": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "subscribedMonthCount": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "tmiSentTs": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "chatReply": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatReply"
              }
            ],
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ChatReply": {
        "type": "object",
        "properties": {
          "parentDisplayName": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "parentMsgBody": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "parentMsgId": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "parentUserId": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "parentUserLogin": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "CheerBadge": {
        "required": [
          "cheerAmount",
          "color"
        ],
        "type": "object",
        "properties": {
          "cheerAmount": {
            "type": "integer",
            "format": "int32"
          },
          "color": {
            "enum": [
              "Gray",
              "Purple",
              "Green",
              "Blue",
              "Red"
            ],
            "type": "string",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "Color": {
        "required": [
          "a",
          "b",
          "g",
          "isEmpty",
          "isKnownColor",
          "isNamedColor",
          "isSystemColor",
          "name",
          "r"
        ],
        "type": "object",
        "properties": {
          "r": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "g": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "b": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "a": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "isKnownColor": {
            "type": "boolean",
            "readOnly": true
          },
          "isEmpty": {
            "type": "boolean",
            "readOnly": true
          },
          "isNamedColor": {
            "type": "boolean",
            "readOnly": true
          },
          "isSystemColor": {
            "type": "boolean",
            "readOnly": true
          },
          "name": {
            "type": "string",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "Emote": {
        "required": [
          "endIndex",
          "startIndex"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "startIndex": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "endIndex": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "imageUrl": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "EmoteSet": {
        "type": "object",
        "properties": {
          "emotes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Emote"
            },
            "nullable": true,
            "readOnly": true
          },
          "rawEmoteSetString": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Image": {
        "required": [
          "byteSize",
          "favorites",
          "height",
          "imageID",
          "isNsfw",
          "uploadedAt",
          "width"
        ],
        "type": "object",
        "properties": {
          "signature": {
            "type": "string",
            "nullable": true
          },
          "extension": {
            "type": "string",
            "nullable": true
          },
          "imageID": {
            "type": "integer",
            "format": "int32"
          },
          "favorites": {
            "type": "integer",
            "format": "int32"
          },
          "dominantColor": {
            "type": "string",
            "nullable": true
          },
          "source": {
            "type": "string",
            "nullable": true
          },
          "artist": {
            "nullable": true
          },
          "uploadedAt": {
            "type": "string",
            "format": "date-time"
          },
          "likedAt": {
            "nullable": true
          },
          "isNsfw": {
            "type": "boolean"
          },
          "width": {
            "type": "integer",
            "format": "int32"
          },
          "height": {
            "type": "integer",
            "format": "int32"
          },
          "byteSize": {
            "type": "integer",
            "format": "int32"
          },
          "url": {
            "type": "string",
            "nullable": true
          },
          "previewURL": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MediaDto": {
        "required": [
          "mediaInfo",
          "uploadStartTime"
        ],
        "type": "object",
        "properties": {
          "mediaInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MediaInfo"
              }
            ]
          },
          "uploadStartTime": {
            "type": "string",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "MediaFileInfo": {
        "required": [
          "extension",
          "fileName",
          "filePath",
          "isLocalFile",
          "type"
        ],
        "type": "object",
        "properties": {
          "type": {
            "enum": [
              "None",
              "Image",
              "Audio",
              "Video",
              "TelegramSticker",
              "Voice",
              "Gif"
            ],
            "type": "string"
          },
          "filePath": {
            "type": "string"
          },
          "isLocalFile": {
            "type": "boolean"
          },
          "fileName": {
            "type": "string"
          },
          "extension": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "MediaInfo": {
        "required": [
          "fileInfo",
          "id",
          "metaInfo",
          "positionInfo",
          "stylesInfo",
          "textInfo"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "readOnly": true
          },
          "textInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MediaTextInfo"
              }
            ]
          },
          "fileInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MediaFileInfo"
              }
            ]
          },
          "positionInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MediaPositionInfo"
              }
            ]
          },
          "metaInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MediaMetaInfo"
              }
            ]
          },
          "stylesInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MediaStylesInfo"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "MediaMetaInfo": {
        "required": [
          "displayName",
          "duration",
          "isLooped",
          "priority",
          "twitchPointsCost",
          "vip"
        ],
        "type": "object",
        "properties": {
          "twitchPointsCost": {
            "type": "integer",
            "format": "int32"
          },
          "twitchGuid": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "vip": {
            "type": "boolean"
          },
          "displayName": {
            "type": "string"
          },
          "isLooped": {
            "type": "boolean"
          },
          "duration": {
            "type": "integer",
            "format": "int32"
          },
          "priority": {
            "enum": [
              "Low",
              "Normal",
              "High"
            ],
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "MediaPositionInfo": {
        "required": [
          "height",
          "isHorizontalCenter",
          "isProportion",
          "isResizeRequires",
          "isRotated",
          "isUseOriginalWidthAndHeight",
          "isVerticallCenter",
          "randomCoordinates",
          "rotation",
          "width",
          "xCoordinate",
          "yCoordinate"
        ],
        "type": "object",
        "properties": {
          "isProportion": {
            "type": "boolean"
          },
          "isResizeRequires": {
            "type": "boolean"
          },
          "height": {
            "type": "integer",
            "format": "int32"
          },
          "width": {
            "type": "integer",
            "format": "int32"
          },
          "isRotated": {
            "type": "boolean"
          },
          "rotation": {
            "type": "integer",
            "format": "int32"
          },
          "xCoordinate": {
            "type": "integer",
            "format": "int32"
          },
          "yCoordinate": {
            "type": "integer",
            "format": "int32"
          },
          "randomCoordinates": {
            "type": "boolean"
          },
          "isVerticallCenter": {
            "type": "boolean"
          },
          "isHorizontalCenter": {
            "type": "boolean"
          },
          "isUseOriginalWidthAndHeight": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "MediaStylesInfo": {
        "required": [
          "isBorder"
        ],
        "type": "object",
        "properties": {
          "isBorder": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "MediaTextInfo": {
        "type": "object",
        "properties": {
          "keyWordsColor": {
            "type": "string",
            "nullable": true
          },
          "triggerWord": {
            "type": "string",
            "nullable": true
          },
          "text": {
            "type": "string",
            "nullable": true
          },
          "textColor": {
            "type": "string",
            "nullable": true
          },
          "keyWordSybmolDelimiter": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PrizeType": {
        "required": [
          "id",
          "image",
          "text"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "image": {
            "type": "string"
          },
          "text": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "StringStringKeyValuePair": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "nullable": true
          },
          "value": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TunaMusicDTO": {
        "required": [
          "data"
        ],
        "type": "object",
        "properties": {
          "data": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TunaMusicData"
              }
            ]
          },
          "hostname": {
            "type": "string",
            "nullable": true
          },
          "timestamp": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TunaMusicData": {
        "required": [
          "album_url",
          "artists",
          "cover",
          "duration",
          "progress",
          "status",
          "title"
        ],
        "type": "object",
        "properties": {
          "cover": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "artists": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "status": {
            "type": "string"
          },
          "progress": {
            "type": "integer",
            "format": "int64"
          },
          "duration": {
            "type": "integer",
            "format": "int64"
          },
          "album_url": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Waifu": {
        "required": [
          "age",
          "imageUrl",
          "isAdded",
          "isMerged",
          "isPrivated",
          "lastOrder",
          "name",
          "orderCount",
          "shikiId",
          "whenAdded"
        ],
        "type": "object",
        "properties": {
          "shikiId": {
            "maxLength": 20,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "maxLength": 200,
            "minLength": 1,
            "type": "string"
          },
          "age": {
            "type": "integer",
            "format": "int64"
          },
          "anime": {
            "type": "string",
            "nullable": true
          },
          "manga": {
            "type": "string",
            "nullable": true
          },
          "whenAdded": {
            "type": "string",
            "format": "date-time"
          },
          "lastOrder": {
            "type": "string",
            "format": "date-time"
          },
          "orderCount": {
            "type": "integer",
            "format": "int32"
          },
          "isPrivated": {
            "type": "boolean"
          },
          "imageUrl": {
            "maxLength": 200,
            "minLength": 1,
            "type": "string"
          },
          "isMerged": {
            "type": "boolean"
          },
          "isAdded": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "tags": [
    {
      "name": "SoundRequestHub"
    },
    {
      "name": "TelegramusHub"
    },
    {
      "name": "TunaHub"
    },
    {
      "name": "SoundBarHub"
    },
    {
      "name": "TelegramusHub"
    }
  ]
}
</file>

<file path="package.json">
{
  "name": "mars.client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --mode development",
    "prod": "vite --mode production --port 9159",
    "predeploy": "yarn vite build",
    "deploy": "gh-pages -d dist",
    "build": "tsc -b && vite build",
    "build:api": "node build-api.js",
    "preview": "vite preview",
    "lint": "eslint \"src/**/*.{ts,tsx,js}\" --fix",
    "lint:noFix": "eslint \"src/**/*.{ts,tsx,js}\"",
    "stylelint": "stylelint \"src/**/*.{css,scss}\" --fix",
    "stylelint:noFix": "stylelint \"src/**/*.{css,scss}\" --quiet",
    "lint:all": "yarn lint"
  },
  "dependencies": {
    "@carefully-coded/react-text-gradient": "^1.0.6",
    "@lit/react": "^1.0.6",
    "@lottiefiles/lottie-player": "^2.0.12",
    "@microsoft/signalr": "^8.0.7",
    "@mkody/twitch-emoticons": "^2.9.0",
    "@redux-devtools/extension": "^3.3.0",
    "@twurple/api": "^7.2.1",
    "@twurple/auth": "^7.2.1",
    "@twurple/chat": "^7.2.1",
    "@types/react-textfit": "^1.1.4",
    "@vkid/sdk": "^2.4.0",
    "animate.css": "^4.1.1",
    "framer-motion": "^12.19.1",
    "gh-pages": "^6.2.0",
    "html-react-parser": "^5.2.2",
    "react": "^19.0.0",
    "react-bootstrap": "^2.10.6",
    "react-canvas-confetti": "^2.0.7",
    "react-dom": "^19.0.0",
    "react-player": "^2.16.0",
    "react-roulette-pro": "^3.2.2",
    "react-router-dom": "^7.0.1",
    "react-shaders": "^0.0.4",
    "react-signalr": "^0.2.24",
    "react-simple-animate": "^3.5.3",
    "react-textfit": "^1.1.1",
    "react-transition-group": "^4.4.5",
    "socket.io-client": "^4.8.1",
    "swagger-typescript-api": "^13.0.23",
    "uuid": "^11.0.3",
    "vite-plugin-mkcert": "^1.17.6",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/compat": "^1.2.6",
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.15.0",
    "@types/node": "^22.13.4",
    "@types/react": "^19.0.1",
    "@types/react-dom": "^19.0.1",
    "@typescript-eslint/eslint-plugin": "^8.24.0",
    "@typescript-eslint/parser": "^8.24.0",
    "@vitejs/plugin-react": "^4.3.4",
    "@vitejs/plugin-react-swc": "^3.8.0",
    "eslint": "^9.15.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.14",
    "eslint-plugin-simple-import-sort": "^12.1.1",
    "globals": "^15.12.0",
    "prettier": "^3.4.1",
    "react-icons": "^5.3.0",
    "repomix": "^0.3.9",
    "sass": "^1.81.0",
    "stylelint": "^16.11.0",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.15.0",
    "vite": "^6.0.1",
    "vite-plugin-singlefile": "^2.1.0",
    "vite-tsconfig-paths": "^5.1.3"
  },
  "packageManager": "yarn@4.6.0",
  "resolutions": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  }
}
</file>

<file path="src/components/ChatVertical/Message.tsx">
import { useEffect, useRef, useState } from "react";
import { ChatMessage } from "../../shared/api/generated/baza";
import styles from "./Message.module.scss";
import { parseContent, replaceBadges, replaceEmotes } from "../../shared/Utils";
import useTwitchStore from "../../shared/twitchStore/twitchStore";
import { Textfit } from "react-textfit";
import "./badge.css";
import anime from "../../shared/styles/animate.module.scss";
import ContentPart from "./ContentPart";

interface Props {
  message: ChatMessage;
}

export function Message({ message }: Props) {
  const [handler, setHandler] = useState(true);
  const badges = useTwitchStore((state) => state.badges);
  const [color, setColor] = useState<string>("");
  const msgRef = useRef<HTMLDivElement>(null);
  const emoteParser = useTwitchStore((state) => state.parser);
  const emoteToLinkParser = useTwitchStore((state) => state.parseToLink);
  const emoteFetcher = useTwitchStore((state) => state.fetcher);
  if (!emoteParser || !emoteFetcher || !emoteToLinkParser) return null;
  const [content] = useState(parseContent(message.message));

  useEffect(() => {
    if (message.isVip) {
      setColor("#e005b9"); //pink
    } else if (message.isBroadcaster) {
      setColor("#e10d00"); // red
    } else if (message.isModerator) {
      setColor("#00ad03"); //green
    } else {
      setColor("transparent");
    }

    setTimeout(
      () => {
        msgRef.current!.onanimationend = () => {
          setHandler(false);
        };
        msgRef.current!.className =
          styles.container + " " + anime.animated + " " + anime.slideOutLeft;
      },
      import.meta.env.DEV ? 30 * 100000 : 30 * 1000,
    );
  }, []);

  // Message component
  return (
    handler && (
      <div
        ref={msgRef}
        className={`${styles.container} ${anime.animated} ${anime.slideInLeft}`}
        style={{
          background: `linear-gradient(100deg, ${color}, transparent 75%) border-box`,
        }}
      >
        {/* Header section with badges and nickname */}
        <div className={styles.head}>
          <div className={styles.badgesAndNickname}>
            <div className={styles.badges}>
              {replaceBadges(badges, message)}
            </div>
            <Textfit
              mode="multi"
              className={styles.nickname}
              min={1}
              style={{
                color: message.colorHex ?? "white",
              }}
            >
              {message.displayName}
            </Textfit>
          </div>
        </div>
        {/* Message content */}
        <div className={styles.messageWrapper}>
          {content &&
            content.map((part) => (
              <ContentPart
                message={message}
                key={part.id}
                part={part}
                className={styles.message}
                style={{ height: 100 / content.length + "%" }}
                convertMediaToJustLinks={
                  !message.isVip &&
                  !message.isBroadcaster &&
                  !message.isModerator
                }
                replaceEmotes={({ message }) =>
                  replaceEmotes({
                    text: message,
                    parser: emoteParser,
                    newParser: emoteToLinkParser,
                  })
                }
              />
            ))}
        </div>
      </div>
    )
  );
}
</file>

<file path="src/components/PyroAlerts/Primitive/Video.tsx">
import React, { useRef, useState, useEffect, useCallback } from "react";
import { Textfit } from "react-textfit";

import { KeyWordText } from "../../../shared/components/KeyWordText";
import { getCoordinates, getRandomRotation } from "../../../shared/Utils";
import styles from "./Media.module.scss";
import { MediaDto } from "../../../shared/api/generated/baza";
import { SignalRContext } from "../../../app";

interface Props {
  callback: () => void;
  MediaInfo: MediaDto;
  isHighPrior?: boolean;
}

export function Video({ MediaInfo, callback, isHighPrior }: Props) {
  const { fileInfo, id, positionInfo, textInfo, metaInfo } =
    MediaInfo.mediaInfo;
  const player = useRef<HTMLVideoElement>(null);
  const [backupTimer, setBackupTimer] = useState<NodeJS.Timeout>();
  const [videoProgress, setVideoProgress] = useState(0);

  const [baseStyles, setBaseStyles] = useState<React.CSSProperties>(
    positionInfo.isProportion
      ? {
          maxWidth: positionInfo.width + "px",
          maxHeight: positionInfo.height + "px",
        }
      : {
          width: positionInfo.width + "px",
          height: positionInfo.height + "px",
          maxHeight: "max-content",
        },
  );

  const muteAll = useCallback(() => {
    if (isHighPrior) {
      SignalRContext.invoke("MuteAll", []);
    }
  }, []);

  const unmuteAll = useCallback(() => {
    if (isHighPrior) {
      SignalRContext.invoke("UnmuteSessions");
    }
  }, []);

  const handleTimeUpdate = useCallback(
    (e: React.SyntheticEvent<HTMLVideoElement>) => {
      const video = e.currentTarget;
      const currentTime = video.currentTime;
      const duration = video.duration;
      const targetDuration = metaInfo.duration;
      const isLooped = metaInfo.isLooped;

      setVideoProgress(currentTime);

      // Проверка достижения конца (с запасом 0.1 сек)
      if (
        (!isLooped && duration - currentTime <= 0.1) ||
        (targetDuration && currentTime >= targetDuration - 0.1)
      ) {
        unmuteAll();
        callback();
      }
    },
    [metaInfo.duration, callback],
  );

  const handleLoadedMetadata = useCallback(
    (event: React.SyntheticEvent<HTMLVideoElement>) => {
      const video = event.currentTarget;

      if (player.current) {
        muteAll();
        const newCords = getCoordinates(player.current, MediaInfo.mediaInfo);

        if (positionInfo.isUseOriginalWidthAndHeight) {
          setBaseStyles((prev) => ({
            ...prev,
            width: video.videoWidth + "px",
            height: video.videoHeight + "px",
          }));
        }

        setBaseStyles((prev) => ({
          ...prev,
          ...newCords,
          ...getRandomRotation(MediaInfo.mediaInfo),
        }));
      }

      // Автовоспроизведение с обработкой ошибок
      video.play().catch(() => {
        video.muted = true;
        video.play();
      });
    },
    [MediaInfo.mediaInfo, positionInfo.isUseOriginalWidthAndHeight],
  );

  useEffect(() => {
    if (!metaInfo.duration || !player.current) return;

    const timer = setTimeout(
      () => {
        if (videoProgress >= metaInfo.duration - 0.5) {
          unmuteAll();
          callback();
        }
      },
      metaInfo.duration * 1000 + 200,
    ); // Длительность + 2 сек буфера

    setBackupTimer(timer);

    return () => {
      if (backupTimer) clearTimeout(backupTimer);
    };
  }, [videoProgress, metaInfo.duration, callback]);

  useEffect(() => {
    setTimeout(() => {
      unmuteAll();
      callback();
    }, metaInfo.duration * 1000 + 1000);
  }, []);

  return (
    <div id={id} className={styles.media} style={baseStyles}>
      <video
        ref={player}
        src={fileInfo.filePath}
        controls={false}
        autoPlay
        loop={metaInfo.isLooped}
        style={{
          maxWidth: baseStyles.maxWidth,
          maxHeight: baseStyles.maxHeight,
          width: baseStyles.width,
          height: baseStyles.height,
        }}
        onError={(e) => {
          console.log(
            "%c" + e,
            "color: #7289DA; -webkit-text-stroke: 2px black; font-size: 72px; font-weight: bold;",
          );
          unmuteAll();
          callback();
        }}
        onTimeUpdate={handleTimeUpdate}
        onLoadedMetadata={handleLoadedMetadata}
        onCanPlayThrough={muteAll}
      />
      <Textfit
        forceSingleModeWidth
        mode="single"
        min={30}
        style={{ justifyContent: "center", display: "flex" }}
      >
        <KeyWordText
          keyWordColor={textInfo.keyWordsColor}
          classNameForKeyWordedSpan={styles.key_word}
          keySymbol="#"
          isQuouted
          keyWordedString={textInfo.text ?? ""}
        />
      </Textfit>
    </div>
  );
}
</file>

<file path="src/components/WaifuAlerts/WaifuAlerts.tsx">
import { useCallback, useEffect, useReducer, useRef, useState } from "react";
import { PrizeType } from "react-roulette-pro";
import { Textfit } from "react-textfit";
import SchoolPride from "react-canvas-confetti/dist/presets/pride";

import { SignalRContext } from "../../app";
import animate from "../../shared/styles/animate.module.scss";
import useTwitchStore from "../../shared/twitchStore/twitchStore";
import Announce from "../../shared/Utils/Announce/Announce";
import { getText, getTitle, shuffleArray, WaifuAlertProps } from "./helper";
import styles from "./WaifuAlerts.module.scss";
import WaifuRoulette from "./WaifuRoulette";
import { Waifu } from "../../shared/api/generated/baza";
import { getRandomColor } from "../../shared/Utils";

enum StateStatus {
  add,
  remove,
  addPrizes,
  shuffle,
}

interface State {
  messages: WaifuAlertProps[];
  prizes?: PrizeType[];
  currentMessage?: WaifuAlertProps;
  isWaifuShowing: boolean;
}

function reducer(
  state: State,
  action: { type: StateStatus; waifu?: WaifuAlertProps; prizes?: PrizeType[] },
): State {
  switch (action.type) {
    case StateStatus.add:
      if (!action.waifu) {
        return state;
      }

      if (!state.isWaifuShowing) {
        return {
          ...state,
          messages: [...state.messages],
          currentMessage: action.waifu,
          isWaifuShowing: true,
        };
      }

      return { ...state, messages: [...state.messages, action.waifu] };

    case StateStatus.remove:
      if (action.waifu === undefined) {
        return { ...state };
      }

      if (state.messages.length > 0) {
        const newArray = state.messages.filter(
          (message) => message.waifu.shikiId !== action.waifu!.waifu.shikiId,
        );

        if (newArray.length > 0) {
          const newWaifu = newArray[0];

          return {
            ...state,
            messages: newArray,
            currentMessage: newWaifu,
            isWaifuShowing: true,
          };
        }

        return {
          ...state,
          isWaifuShowing: false,
          messages: newArray,
          currentMessage: undefined,
        };
      }

      return {
        ...state,
        messages: [],
        currentMessage: undefined,
        isWaifuShowing: false,
      };

    case StateStatus.addPrizes:
      return {
        ...state,
        prizes: action.prizes,
      };
    case StateStatus.shuffle:
      return {
        ...state,
        prizes: shuffleArray(state.prizes ?? []),
      };
  }
}

export default function WaifuAlerts() {
  document.title = "WaifuAlerts";

  const initState: State = {
    messages: [],
    isWaifuShowing: false,
  };

  const [{ currentMessage, prizes }, dispatch] = useReducer(reducer, initState);
  const [announced, setAnnounced] = useState(false);
  const divHard = useRef<HTMLDivElement>(null);
  const [isRouletted, setIsRouletted] = useState(false);
  const [rouletteIndex, setRouletteIndex] = useState(-1);
  const sendMessage = useTwitchStore((state) => state.sendMsgToPyrokxnezxz);

  SignalRContext.useSignalREffect(
    "waifuroll",
    (message, displayName: string, color?: string) => {
      const parsedMessage: WaifuAlertProps = {
        waifu: message,
        displayName,
        color,
      };
      handleAddEvent(parsedMessage);
    },
    [],
  );

  SignalRContext.useSignalREffect(
    "addnewwaifu",
    (message: Waifu, displayName: string, color?: string) => {
      message.isAdded = true;
      const parsedMessage: WaifuAlertProps = {
        waifu: message,
        displayName,
        color,
      };
      handleAddEvent(parsedMessage);
    },
    [],
  );

  SignalRContext.useSignalREffect(
    "Mergewaifu",
    (message: Waifu, displayName: string, avatar?: string, color?: string) => {
      message.isMerged = true;
      const parsedMessage: WaifuAlertProps = {
        waifu: message,
        displayName,
        color,
        avatarUrl: avatar,
      };
      handleAddEvent(parsedMessage);
    },
    [],
  );

  SignalRContext.useSignalREffect(
    "UpdateWaifuPrizes",
    async (prizes: PrizeType[]) => {
      dispatch({ type: StateStatus.addPrizes, prizes });
    },
    [],
  );

  function handleAddEvent(waifu: WaifuAlertProps) {
    dispatch({ type: StateStatus.add, waifu });
  }

  function handleRemoveEvent(waifu: WaifuAlertProps) {
    dispatch({ type: StateStatus.remove, waifu });
  }

  function shufflePrizesEvent() {
    dispatch({ type: StateStatus.shuffle });
  }

  useEffect(() => {
    if (currentMessage) {
      if (prizes) {
        const index = prizes.findIndex(
          (prize) => prize.id === currentMessage.waifu.shikiId,
        );
        setRouletteIndex(index);
      }
    }
  }, [prizes, currentMessage]);

  useEffect(() => {
    if (currentMessage) {
      if (currentMessage.waifu.isMerged && !currentMessage.waifu.isAdded) {
        setIsRouletted(true);
      }
    }
  }, [currentMessage]);

  const muteAll = useCallback(() => {
    SignalRContext.invoke("MuteAll", []);
  }, []);

  const unmuteAll = useCallback(() => {
    SignalRContext.invoke("UnmuteSessions");
  }, []);

  const error = useCallback(
    (currentMessage: WaifuAlertProps) => {
      unmuteAll();
      handleRemoveEvent(currentMessage);
      throw Error("Failed to play audio");
    },
    [currentMessage],
  );

  return (
    <>
      {!announced && (
        <Announce title={"WaifuRoll"} callback={() => setAnnounced(true)} />
      )}
      {currentMessage && !isRouletted && rouletteIndex !== -1 && (
        <WaifuRoulette
          key={currentMessage.waifu.shikiId}
          callback={() => {
            setIsRouletted(true);
            setRouletteIndex(-1);
          }}
          rouletteIndex={rouletteIndex}
          prizes={prizes || []}
          name={currentMessage.displayName}
          color={currentMessage.color}
        />
      )}
      {currentMessage &&
        isRouletted &&
        !currentMessage.waifu.isAdded &&
        !currentMessage.waifu.isMerged && (
          <div
            id={currentMessage.waifu.shikiId}
            key={currentMessage.waifu.shikiId}
            ref={divHard}
            className={
              styles.baza + " " + animate.bounceIn + " " + animate.animated
            }
          >
            <div className={styles["alert-box"]}>
              <img
                src={currentMessage.waifu.imageUrl}
                style={{ height: "498px", width: "320px" }}
                onLoad={() => {
                  setTimeout(() => {
                    divHard.current!.onanimationend = () => {
                      handleRemoveEvent(currentMessage);
                      setRouletteIndex(-1);
                      setIsRouletted(false);
                      shufflePrizesEvent();
                    };

                    divHard.current!.className =
                      styles.baza +
                      " " +
                      animate.bounceOut +
                      " " +
                      animate.animated;
                  }, 7000);
                  sendMessage(
                    `@${currentMessage.displayName}, ${getText(currentMessage)} ${getTitle(currentMessage)}!`,
                  );
                }}
              />
            </div>
            <div className={styles["alert-box"]}>
              <span
                className="text-shadow block-text"
                style={{ color: "white" }}
              >
                <Textfit min={1} max={1500} forceSingleModeWidth>
                  {currentMessage.displayName.toUpperCase()}
                </Textfit>
              </span>
              <span
                className="text-shadow block-text"
                style={{ color: "cornflowerblue" }}
              >
                <Textfit min={1} max={1500} forceSingleModeWidth>
                  {getText(currentMessage)}
                </Textfit>
              </span>
              <span className="text-shadow block-text" style={{ color: "red" }}>
                <Textfit min={1} max={1500} forceSingleModeWidth>
                  {getTitle(currentMessage)}
                </Textfit>
              </span>
            </div>
          </div>
        )}
      {currentMessage && isRouletted && currentMessage.waifu.isMerged && (
        <>
          {/** Confetty */}
          <SchoolPride
            width="100%"
            height="100%"
            autorun={{ speed: 30, duration: 20 * 1000 }}
            decorateOptions={(): confetti.Options => {
              return {
                particleCount: 2,
                angle: 60,
                spread: 55,
                origin: { x: 0 },
                colors: ["#000000", "#FF0000", "#FFFFFF"],
              };
            }}
          />
          <SchoolPride
            width="100%"
            height="100%"
            autorun={{ speed: 30, duration: 20 * 1000 }}
            decorateOptions={(): confetti.Options => {
              return {
                particleCount: 2,
                angle: 120,
                spread: 55,
                origin: { x: 1 },
                colors: ["#000000", "#FF0000", "#FFFFFF"],
              };
            }}
          />
          {/** Images With text */}
          <div className={styles["merge-container"]}>
            <div className={styles["merge-image"]}>
              <img src={currentMessage.avatarUrl}></img>
            </div>
            <div className={styles["merge-text"]}>
              <Textfit
                style={{ color: "white" }}
                mode="multi"
                min={1}
                max={2000}
              >
                Поздравляем{" "}
                <span style={{ color: currentMessage.color }}>
                  {currentMessage.displayName}
                </span>{" "}
                и{" "}
                <span style={{ color: getRandomColor() }}>
                  {currentMessage.waifu.name}{" "}
                </span>{" "}
                из{" "}
                <span
                  style={{
                    color: currentMessage.waifu.anime ? "blue" : "gold",
                  }}
                >
                  {getTitle(currentMessage)}
                </span>{" "}
                с свадьбой!
              </Textfit>
            </div>
            <div className={styles["merge-image"]}>
              <img src={currentMessage.waifu.imageUrl}></img>
            </div>
          </div>
          {/** Audio */}
          <audio
            key={currentMessage.waifu.shikiId}
            controls={false}
            autoPlay
            onError={() => error(currentMessage)}
            onEnded={() => {
              setIsRouletted(true);
              setRouletteIndex(-1);
              unmuteAll();
              handleRemoveEvent(currentMessage);
            }}
            onCanPlay={(event) => {
              try {
                event.currentTarget?.play();
              } catch (e) {
                event.currentTarget.muted = true;
                event.currentTarget?.play();
              }
            }}
            onCanPlayThrough={() => muteAll()}
          >
            <source
              src={import.meta.env.VITE_BASE_PATH + "Alerts/svadba.mp3"}
            />
          </audio>
        </>
      )}
    </>
  );
}
</file>

<file path="src/components/ScreenParticles/EmojiParticles.tsx">
import { JSX, useEffect, useState } from "react";
import { getEmojisSrcFromText } from "../../shared/Utils";
import useTwitchStore from "../../shared/twitchStore/twitchStore";
import { ChatMessage } from "../../shared/api/generated/baza";
import Fireworks from "react-canvas-confetti/dist/presets/fireworks";
import { randomInRange } from ".";

interface imageData {
  src: string;
  scalar?: number;
  x?: number;
  y?: number;
  width?: number;
  height?: number;
}

async function shapeFromImage(imageData: imageData) {
  const { src, scalar = 1 } = imageData;
  const scale = 1 / scalar;

  const img = new Image();
  img.src = src;

  await new Promise((res) => img.addEventListener("load", res));

  const size = 10 * scalar;

  const sx = imageData.x ?? 0;
  const sy = imageData.y ?? 0;
  const sWidth = imageData.width ?? img.naturalWidth;
  const sHeight = imageData.height ?? img.naturalHeight;

  const x = 0;
  const y = 0;
  const width = size;
  const height = (size * sHeight) / sWidth;

  const canvas = new OffscreenCanvas(width, height);
  const ctx = canvas.getContext("2d");
  ctx?.drawImage(img, sx, sy, sWidth, sHeight, x, y, width, height);

  return {
    type: "bitmap",
    bitmap: canvas.transferToImageBitmap(),
    matrix: [scale, 0, 0, scale, (-width * scale) / 2, (-height * scale) / 2],
  };
}

interface Props {
  input: string | ChatMessage;
  scalar?: number;
}

export async function getBase64(url: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
      if (xhr.status === 200) {
        const reader = new FileReader();
        reader.onloadend = function () {
          if (reader.result) {
            resolve(reader.result.toString());
          } else {
            reject(new Error("Failed to read file"));
          }
        };
        reader.onerror = function () {
          reject(new Error("Failed to read file"));
        };
        reader.readAsDataURL(xhr.response);
      } else {
        reject(new Error(`Failed to load file: ${xhr.statusText}`));
      }
    };
    xhr.onerror = function () {
      reject(new Error("Failed to send request"));
    };
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.send();
  });
}

const ConfettiImage = ({ input, scalar = 10 }: Props) => {
  const [shapes, setShapes] = useState<Array<any>>([]);
  const parser = useTwitchStore((state) => state.parser);
  const parserToLink = useTwitchStore((state) => state.parseToLink);
  if (!parser || !parserToLink) {
    return undefined;
  }
  const [images, _] = useState(
    getEmojisSrcFromText(input, parser, parserToLink),
  );
  const [element, setElement] = useState<JSX.Element | null>(null);

  useEffect(() => {
    if (images?.length && images.length > 0) {
      images.forEach(async (image) => {
        const base64 = await getBase64(image);
        const aa = await shapeFromImage({ src: base64, scalar });
        setShapes((prev) => [...prev, aa]);
      });
    }
  }, [images]);

  useEffect(() => {
    if (shapes.length > 0) {
      setElement(
        <Fireworks
          width="100%"
          height="100%"
          autorun={{ speed: 3, duration: 10000 }}
          decorateOptions={() => {
            return {
              startVelocity: 30,
              spread: 360,
              ticks: 60,
              particleCount: 30,
              shapes,
              scalar,
              origin: {
                x: randomInRange(0, 1),
                y: randomInRange(0, 1),
              },
            };
          }}
        />,
      );
    }
  }, [shapes, scalar]);

  return element;
};

export default ConfettiImage;
</file>

<file path="src/components/PyroAlerts/PyroAlerts.tsx">
import { useCallback, useEffect, useState } from "react";
import { SignalRContext } from "../../app";
import Announce from "../../shared/Utils/Announce/Announce";
import {
  MediaDto,
  MediaMetaInfoPriorityEnum,
} from "../../shared/api/generated/baza";
import { v4 as uuidv4 } from "uuid";
import HighPriorityAlert from "./HighPriorityAlert";
import Alert from "./Alert";

export default function PyroAlerts() {
  const [messages, setMessages] = useState<MediaDto[]>([]);
  const [highPriorityQueue, setHighPriorityQueue] = useState<MediaDto[]>([]);
  const [currentHighPriority, setCurrentHighPriority] =
    useState<MediaDto | null>(null);
  const [announced, setAnnounced] = useState(false);

  const handleAlert = useCallback((message: MediaDto) => {
    message.mediaInfo.id = uuidv4();

    switch (message.mediaInfo.metaInfo.priority) {
      case MediaMetaInfoPriorityEnum.High:
        const parsedMessage: MediaDto = {
          ...message,
          mediaInfo: {
            ...message.mediaInfo,
            fileInfo: {
              ...message.mediaInfo.fileInfo,
              filePath: message.mediaInfo.fileInfo.isLocalFile
                ? import.meta.env.VITE_BASE_PATH +
                  message.mediaInfo.fileInfo.filePath
                : message.mediaInfo.fileInfo.filePath,
            },
          },
        };

        setHighPriorityQueue((prev) => [...prev, parsedMessage]); // Добавляем в очередь высокоприоритетных
        setMessages([]);
        break;
      case MediaMetaInfoPriorityEnum.Low:
      case MediaMetaInfoPriorityEnum.Normal:
        const coolMessage: MediaDto = {
          ...message,
          mediaInfo: {
            ...message.mediaInfo,
            fileInfo: {
              ...message.mediaInfo.fileInfo,
              filePath: message.mediaInfo.fileInfo.isLocalFile
                ? import.meta.env.VITE_BASE_PATH +
                  message.mediaInfo.fileInfo.filePath
                : message.mediaInfo.fileInfo.filePath,
            },
          },
        };

        setMessages((prev) => [...prev, coolMessage]);
        break;
    }
  }, []);

  const remove = useCallback((message: MediaDto) => {
    setMessages((prev) =>
      prev.filter((m) => m.mediaInfo.id !== message.mediaInfo.id),
    );
  }, []);

  const removeHighPrior = useCallback((message: MediaDto) => {
    setHighPriorityQueue((prev) =>
      prev.filter((m) => m.mediaInfo.id !== message.mediaInfo.id),
    );

    const newPriority = highPriorityQueue.some((e) => e)
      ? highPriorityQueue[0]
      : null;
    setCurrentHighPriority(newPriority);
  }, []);

  // Эффект для обработки очереди высокоприоритетных алертов
  useEffect(() => {
    if (highPriorityQueue.length > 0 && !currentHighPriority) {
      // Берем первый алерт из очереди
      const nextAlert = highPriorityQueue[0];
      setCurrentHighPriority(nextAlert);

      // Удаляем его из очереди через 2 секунды (время показа)
      const timer = setTimeout(() => {
        setHighPriorityQueue((prev) => prev.slice(1));
        setCurrentHighPriority(null);
      }, 2000);

      return () => clearTimeout(timer);
    }
  }, [highPriorityQueue, currentHighPriority]);

  // Подписки на SignalR события
  SignalRContext.useSignalREffect("alert", handleAlert, [handleAlert]);
  SignalRContext.useSignalREffect(
    "alerts",
    (messages: MediaDto[]) => messages.forEach(handleAlert),
    [handleAlert],
  );

  return (
    <>
      {!announced && (
        <Announce title={"PyroAlerts"} callback={() => setAnnounced(true)} />
      )}

      {/* Рендерим текущий высокоприоритетный алерт */}
      {currentHighPriority && (
        <HighPriorityAlert
          key={currentHighPriority.mediaInfo.id}
          message={currentHighPriority}
          type={currentHighPriority.mediaInfo.fileInfo.type}
          callback={() => removeHighPrior(currentHighPriority)}
        />
      )}

      {/* Рендерим обычные алерты, если нет высокоприоритетных */}
      {!currentHighPriority &&
        messages.map((messageProps) => (
          <Alert
            key={messageProps.mediaInfo.id}
            message={messageProps}
            remove={remove}
          />
        ))}
    </>
  );
}
</file>

<file path="src/routes/Routes.tsx">
import { BrowserRouter, Navigate, Route, Routes } from "react-router-dom";
import { LinktreeMenu } from "./LinkTree/LinkTreeMenu"; // Импортируем новый компонент
import { FumoFriday } from "../components/FumoFriday";
import HighliteMessage from "../components/HighliteMessage/HighliteMessage";
import WaifuAlerts from "../components/WaifuAlerts/WaifuAlerts";
import Manager from "../components/ScreenParticles/Manager";
import ChatHorizontal from "../components/ChatHorizontal/ChatHorizontal";
import ChatVertical from "../components/ChatVertical/ChatVertical";
import { TrackList } from "../components/SoundRequest/TrackList/TrackList";
import { VideoScreen } from "../components/SoundRequest/VideoScreen/VideoScreen";
import PyroAlerts from "../components/PyroAlerts/PyroAlerts";
import RandomMem from "../components/RandomMem/RandomMem";
import CurrentTrackSignalRHubWrapper from "../components/SoundRequest/CurrentTrack/SignalRHubWrapper";

const PrivateRoutes = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<LinktreeMenu />} /> {/* Главное меню */}
        <Route path="/pyroalerts" element={<PyroAlerts />} />
        <Route path="/randommem" element={<RandomMem />} />
        <Route path="/waifu" element={<WaifuAlerts />} />
        <Route path="/fumofriday" element={<FumoFriday />} />
        <Route path="/highlite" element={<HighliteMessage />} />
        <Route path="/confetti" element={<Manager />} />
        <Route path="/chath" element={<ChatHorizontal />} />
        <Route path="/chatv" element={<ChatVertical />} />
        <Route path="/sr/tracklist" element={<TrackList />} />
        <Route path="/sr/videoscreen" element={<VideoScreen />} />
        <Route
          path="/sr/currenttrack"
          element={<CurrentTrackSignalRHubWrapper />}
        />
        <Route path="*" element={<Navigate to="/" />} />
        {/* Редирект на меню */}
      </Routes>
    </BrowserRouter>
  );
};

PrivateRoutes.displayName = "PrivateRoutes";

export default PrivateRoutes;
</file>

<file path="src/shared/Utils/index.ts">
/* eslint-disable react-hooks/rules-of-hooks */
import parse from "html-react-parser";

import emoticons from "@mkody/twitch-emoticons";
import { HelixChatBadgeSet } from "@twurple/api";
import { ChatMessage, MediaInfo } from "../api/generated/baza";
import { ChatMessage as TwitchChatMessage } from "@twurple/chat";
import { HighliteMessageProps } from "../../components/HighliteMessage/Message";
import React from "react";
import { v4 as randomUUID } from "uuid";
import { addMimeTypesToImgTags } from "../MIME_types";

export { BigTextBlockForAudio } from "./BigTexts/BigTextBlockForAudio";
export { BigTextBlockForVoice } from "./BigTexts/BigTextBlockForVoice";
export { FullText } from "./FullText/FullText";

export function replaceEmotes({
  text,
  parser,
  newParser,
}: {
  text?: string | ChatMessage;
  parser: emoticons.EmoteParser;
  newParser: emoticons.EmoteParser;
}) {
  if (!text) {
    return undefined;
  }

  let resultText: string = "";

  if (typeof text === "string") {
    resultText = text.replace(/[\u{E0000}-\u{E007F}]/gu, "");
    if (text) {
      if (parser) {
        resultText = parser.parse(text, 1);
        // text = text.replaceAll(new RegExp("https", "g"), "http");
      }
    }
  } else if ("message" in text && typeof text.message === "string") {
    var message = text as ChatMessage;

    if (message.message === undefined) {
      return undefined;
    }

    resultText = message.message.replace(/[\u{E0000}-\u{E007F}]/gu, "");

    message.emoteSet?.emotes?.forEach((emote) => {
      if (
        emote.name === undefined ||
        emote.imageUrl === undefined ||
        message.message === undefined
      ) {
        return undefined;
      }

      resultText = resultText.replaceAll(
        new RegExp(`(?<!<[^>]*)${escapeRegExp(emote.name)}(?![^<]*>)`, "g"),
        `<img class="emote"
        srcset="//static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/1.0 1x, //static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/light/2.0 2x, //static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/4.0 4x" alt="${emote.name}" 
        loading="lazy"
        decoding="async" />`,
      );
    });

    function escapeRegExp(string: string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    const parsedText = newParser.parse(resultText);
    resultText = addMimeTypesToImgTags(parsedText);
  } else {
    throw new Error("Invalid message type");
  }

  if (!text) {
    return undefined;
  }

  const result = parse(resultText);

  return result;
}

export function AddBorderToElement(info: MediaInfo): React.CSSProperties {
  return {
    border: `6px solid ${info.textInfo.keyWordsColor}`,
    borderRadius: "50px",
  };
}

export function getRandomInt(min: number, max: number): number {
  if (min >= -1 && max <= 1) {
    function getRandomInRange(min: number, max: number): number {
      // Проверяем, что min и max находятся в допустимом диапазоне
      if (min < -1 || max > 1) {
        throw new Error("min must be >= -1 and max must be <= 1");
      }

      // Генерируем случайное число в диапазоне [min, max)
      const randomValue = Math.random() * (max - min) + min;

      // Округляем до 3 знаков после запятой
      return Math.round(randomValue * 1000) / 1000;
    }

    return getRandomInRange(min, max);
  }

  // Создаем буфер для одного 32-битного беззнакового целого числа
  const buffer = new Uint32Array(1);
  window.crypto.getRandomValues(buffer);
  const randomNumber = buffer[0] / (0xffffffff + 1); // Преобразовываем в число от 0 до 1 (включительно)

  // Преобразуем в число в заданном диапазоне
  return Math.floor(randomNumber * (max - min + 1)) + min;
}

export function getCoordinates(
  ref: HTMLImageElement | HTMLVideoElement | HTMLDivElement,
  info: MediaInfo,
): React.CSSProperties {
  const returnObj: React.CSSProperties = {};
  const { positionInfo } = info;

  // Получаем размеры элемента в зависимости от его типа
  let elementWidth: number;
  let elementHeight: number;

  if ('width' in ref && typeof ref.width === 'number') {
    // Для элементов с width/height свойствами (img, video)
    elementWidth = ref.width;
    elementHeight = ref.height;
  } else {
    // Для div и других элементов используем offsetWidth/offsetHeight
    elementWidth = ref.offsetWidth || positionInfo.width || 0;
    elementHeight = ref.offsetHeight || positionInfo.height || 0;
    
    // Если размеры не определены, устанавливаем из positionInfo
    if (!elementWidth && positionInfo.width) {
      elementWidth = positionInfo.width;
    }
    if (!elementHeight && positionInfo.height) {
      elementHeight = positionInfo.height;
    }
  }

  // Случайный вариант позиционирования
  if (positionInfo.randomCoordinates) {
    const maxX = Math.max(0, window.innerWidth - elementWidth);
    const maxY = Math.max(0, window.innerHeight - elementHeight);
    
    returnObj.left = `${getRandomInt(0, maxX)}px`;
    returnObj.top = `${getRandomInt(0, maxY)}px`;
    returnObj.position = 'absolute';
    return returnObj;
  }

  // Центрирование
  if (positionInfo.isHorizontalCenter && positionInfo.isVerticallCenter) {
    return {
      position: 'absolute',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
    };
  }

  if (positionInfo.isHorizontalCenter) {
    returnObj.position = 'absolute';
    returnObj.left = '50%';
    returnObj.transform = 'translateX(-50%)';
    returnObj.top = positionInfo.yCoordinate !== undefined 
      ? `${positionInfo.yCoordinate}px` 
      : undefined;
    return returnObj;
  }

  if (positionInfo.isVerticallCenter) {
    returnObj.position = 'absolute';
    returnObj.top = '50%';
    returnObj.transform = 'translateY(-50%)';
    returnObj.left = positionInfo.xCoordinate !== undefined 
      ? `${positionInfo.xCoordinate}px` 
      : undefined;
    return returnObj;
  }

  // Явное задание координат (без центрирования)
  if (positionInfo.xCoordinate !== undefined) {
    returnObj.left = `${positionInfo.xCoordinate}px`;
  }
  if (positionInfo.yCoordinate !== undefined) {
    returnObj.top = `${positionInfo.yCoordinate}px`;
  }

  // Если координаты заданы (явно или через центрирование) - добавляем absolute
  if (returnObj.left !== undefined || returnObj.top !== undefined) {
    returnObj.position = 'absolute';
  }

  return returnObj;
}

export function getFileExtensionWithoutDot(extension: string | null) {
  const result = extension?.startsWith(".")
    ? extension.substring(1)
    : extension;

  return result;
}

export function getRandomRotation(mediaInfo: MediaInfo) {
  const returnObj: React.CSSProperties = {};

  if (mediaInfo?.positionInfo.isRotated) {
    returnObj.transform = `rotate(${getRandomInt(mediaInfo.positionInfo.rotation * -1, mediaInfo.positionInfo.rotation)}deg)`;
  }

  return returnObj;
}

export const getRandomColor = (opacity: number = 1): string => {
  // Генерируем случайные значения для красного, зеленого и синего каналов
  const r = Math.floor(Math.random() * 256); // Случайное число от 0 до 255
  const g = Math.floor(Math.random() * 256); // Случайное число от 0 до 255
  const b = Math.floor(Math.random() * 256); // Случайное число от 0 до 255

  // Возвращаем цвет в формате rgba
  return `rgba(${r}, ${g}, ${b}, ${opacity})`;
};

export function replaceBadges(
  badges: HelixChatBadgeSet[],
  chatMessage: ChatMessage | TwitchChatMessage,
) {
  var text: string | undefined = "";
  var sub = "";

  if (chatMessage instanceof TwitchChatMessage) {
    text = chatMessage.text;

    chatMessage.userInfo.badges.forEach((v, k) => {
      const set = badges.find((e) => e.id == k);
      const lastVersion = set?.versions.find((e) => e.id == v);

      if (!lastVersion) {
        return undefined;
      }

      const link = lastVersion.getImageUrl(4);
      sub = sub + `<img class="badge" src="${link}" type="image/png">\n`;
    });
  } else if (chatMessage.badges !== undefined) {
    text = chatMessage.message;

    chatMessage.badges.forEach((b) => {
      const set = badges.find((e) => e.id == b.key);
      const lastVersion = set?.versions?.find((e) => e.id == b.value);

      if (!lastVersion) {
        return undefined;
      }

      const link = lastVersion.getImageUrl(4);
      sub = sub + `<img class="badge" src="${link}" type="image/png">\n`;
    });
  }

  if (!text) {
    return undefined;
  }

  const result = parse(sub);

  if (typeof result === "string") {
    return undefined;
  }

  return result;
}

export function getEmojisSrcFromText(
  text: string | ChatMessage,
  client: emoticons.EmoteParser,
  newParser: emoticons.EmoteParser,
) {
  if (typeof text === "string") {
    text = text.replace(/[\u{E0000}-\u{E007F}]/gu, "");
    const messages = text.split(" ");
    const result = messages.map((message) => {
      return client.parse(message, 1);
    });
    return result;
  } else if ("message" in text && typeof text.message === "string") {
    var message = text as ChatMessage;

    if (
      message.message === undefined ||
      message.emoteSet === undefined ||
      message.emoteSet.emotes === undefined
    ) {
      return undefined;
    }

    message.message = message.message.replace(/[\u{E0000}-\u{E007F}]/gu, "");

    const urls = message.emoteSet.emotes.map((emote) => {
      if (emote.name !== undefined) {
        message.message = message.message?.replace(emote.name, "");
      }
      return emote.imageUrl;
    });

    const newMEssages = message.message.trim().split(" ");

    newMEssages.forEach((message) => {
      urls.push(newParser.parse(message, 1));
    });

    return urls.filter((url) => url !== undefined);
  } else {
    throw new Error("text must be string or ChatMessage");
  }
}

export const isWhiteColor = (color: string) => {
  if (color === "white") {
    return true;
  }

  if (color === "#ffffff") {
    return true;
  }

  if (color === "rgb(255, 255, 255)") {
    return true;
  }
};

export const getNotWhiteColor = (opacity?: number) => {
  while (true) {
    const color: string = getRandomColor(opacity);

    if (!isWhiteColor(color)) {
      return color;
    }
  }
};

export const isVideo = (currentMessage: HighliteMessageProps) =>
  (currentMessage?.faceImage.url?.includes(".mp4") ||
    currentMessage?.faceImage.url?.includes(".webm")) ??
  false;

/**
 * Конвертирует цвет из hex в rgba.
 * @param hex - Цвет в формате hex (например, "#FF5733").
 * @param opacity - Прозрачность (от 0 до 1).
 * @returns Цвет в формате rgba (например, "rgba(255, 87, 51, 0.7)").
 */
export const hexToRgba = (hex: string, opacity: number = 1): string => {
  // Удаляем символ #, если он есть
  hex = hex.replace("#", "");

  // Преобразуем hex в RGB
  let r: number, g: number, b: number;

  if (hex.length === 3) {
    // Если hex в сокращенном формате (например, "#F53")
    r = parseInt(hex[0] + hex[0], 16);
    g = parseInt(hex[1] + hex[1], 16);
    b = parseInt(hex[2] + hex[2], 16);
  } else if (hex.length === 6) {
    // Если hex в полном формате (например, "#FF5733")
    r = parseInt(hex.substring(0, 2), 16);
    g = parseInt(hex.substring(2, 4), 16);
    b = parseInt(hex.substring(4, 6), 16);
  } else {
    throw new Error('Неверный формат hex. Используйте "#FFF" или "#FFFFFF".');
  }

  // Возвращаем цвет в формате rgba
  return `rgba(${r}, ${g}, ${b}, ${opacity})`;
};

export interface ContentPart {
  id: string;
  type: "text" | "image" | "video" | "link";
  source?: string; // только для image, video, link
  content: string; // исходный текст или URL
}

export function parseContent(text?: string): ContentPart[] | undefined {
  if (!text) return undefined;

  text = text.trim();

  const result: ContentPart[] = [];
  let currentText: string[] = [];

  // Улучшенное разбиение с очисткой невидимых символов
  const parts = text
    .replace(/[\u{E0000}-\u{E007F}]/gu, "")
    .split(/\s+/)
    .filter((part) => part.trim().length > 0);

  for (const part of parts) {
    if (part.startsWith("https://") || part.startsWith("http://")) {
      // Добавляем накопленный текст
      if (currentText.length > 0) {
        result.push({
          type: "text",
          content: currentText.join(" "),
          id: randomUUID(),
        });
        currentText = [];
      }

      // Определяем тип контента
      if (
        part.includes(".mp4") ||
        part.includes(".webm") ||
        part.includes(".ogg")
      ) {
        result.push({
          id: randomUUID(),

          type: "video",
          source: part,
          content: part,
        });
      } else if (
        part.includes(".jpeg") ||
        part.includes(".jpg") ||
        part.includes(".png") ||
        part.includes(".gif") ||
        part.includes(".svg") ||
        part.includes(".webp")
      ) {
        result.push({
          id: randomUUID(),

          type: "image",
          source: part,
          content: part,
        });
      } else {
        result.push({
          id: randomUUID(),

          type: "link",
          source: part,
          content: part,
        });
      }
    } else {
      if (!!part) {
        currentText.push(part);
      }
    }
  }

  // Добавляем оставшийся текст
  if (currentText.length > 0) {
    result.push({
      id: randomUUID(),

      type: "text",
      content: currentText.join(" "),
    });
  }

  return result;
}
</file>

</files>
